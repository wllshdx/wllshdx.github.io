<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wllblog</title>
  
  <subtitle>wll的个人博客</subtitle>
  <link href="https://wllshdx.github.io/atom.xml" rel="self"/>
  
  <link href="https://wllshdx.github.io/"/>
  <updated>2021-03-25T03:15:16.629Z</updated>
  <id>https://wllshdx.github.io/</id>
  
  <author>
    <name>wll</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springMVC</title>
    <link href="https://wllshdx.github.io/2021/03/24/SpringMVC/"/>
    <id>https://wllshdx.github.io/2021/03/24/SpringMVC/</id>
    <published>2021-03-24T09:58:59.000Z</published>
    <updated>2021-03-25T03:15:16.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="请求流程图"><a href="#请求流程图" class="headerlink" title="请求流程图"></a>请求流程图</h1><p>这个流程图主要是对spring mvc处理一个请求的大致说明，许多流程处理细节，一张图无法全部展示，会分模块在后续篇章说明。</p><p>spring mvc默认只有一个servlet映射所有请求（/*）然后进行分发处理，除非用户自定义servlet映射指定路径的请求进行处理，所有请求都会进入DispatcherServlet进行分发处理。</p><p>DispatcherServlet的类继承关系如下：</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324180004774.png" alt="image-20210324180004774"></p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324180047485.png" alt="image-20210324180047485"></p><h3 id="HandlerMethod对象"><a href="#HandlerMethod对象" class="headerlink" title="HandlerMethod对象"></a>HandlerMethod对象</h3><p>用处：可以自定义一些注解，实现权限认证</p><p>通过反射机制获取</p><h4 id="Handler和HandlerMethod"><a href="#Handler和HandlerMethod" class="headerlink" title="Handler和HandlerMethod"></a>Handler和HandlerMethod</h4><p>Handler：绑定了注解@RequestMapping和@Controller的类</p><p>HandlerMethod：就是Handler下某个绑定@RequestMapping注解的方法（GetMapping、PostMapping…等都绑定的有注解@RequestMapping，spring mvc在做注解解析处理生成代理对象等的时候，会做值的合并等处理，所以最终都是用RequestMapping的注解来计算，所以@Controller和@RestController的处理等同）</p><p>HandlerMethod封装了很多属性，在访问请求方法的时候可以方便的访问到方法、方法参数、方法上的注解、所属类等并且对方法参数封装处理，也可以方便的访问到方法参数的注解等信息。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 虽然Object类型，但是注册handlerMethod时候构造的时候有可能传入的是一个String类型的bean name</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 见名知义，我调试的时候，传入的是DefaultListableBeanFactory，如果bean属性是Sring的beanName就可以用beanName获取到对应的bean作用Handler</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法所属类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注册的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 被桥接的方法,如果method是原生的，这个属性的值就是method</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 封装方法参数的类实例，一个MethodParameter就是一个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Http状态码</span></span><br><span class="line"><span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ResponseStatus注解的reason值</span></span><br><span class="line"><span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>顺便提下：</strong></p><p>​    HandlerMethod还有两个子类，分别为InvocableHandlerMethod和ServletInvocableHandlerMethod，他们的继承关系如下：</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324180110112.png" alt="image-20210324180110112"></p><p>InvocableHandlerMethod是在HandlerMethod上增加了调用的功能，而ServletInvocableHandlerMethod是在InvocableHandlerMethod增加了返回值和响应状态码的处理，另外在ServletInvocableHandlerMethod有个内部类ConcurrentResultHandlerMethod继承于它，支持异常调用结果处理。在查找到Handler适配器时候发起对方法调用的便是用ServletInvocableHandlerMethod。</p><p>Invocable 可调用的</p><h1 id="mvc-annotation-driven注解的作用"><a href="#mvc-annotation-driven注解的作用" class="headerlink" title="mvc:annotation-driven注解的作用"></a>mvc:annotation-driven注解的作用</h1><p><a href="mvc:annotation-driven">mvc:annotation-driven</a>会自动注册RequestMappingHandlerMapping与RequestMappingHandlerAdapter两个Bean,这是Spring MVC为@Controller分发请求所必需的，并且提供了数据绑定支持，@NumberFormatannotation支持，@DateTimeFormat支持,@Valid支持读写XML的支持（JAXB）和读写JSON的支持（默认Jackson）等功能。</p><p>使用该注解后的springmvc-config.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  spring 可以自动去扫描 base-package下面的包或子包下面的Java文件，如果扫描到有Spring的相关注解的类，则把这些类注册为Spring的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.fkit.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置配置方案 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用默认的Servlet来响应静态文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/WEB-INF/content/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>.jsp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ssm项目乱码问题"><a href="#ssm项目乱码问题" class="headerlink" title="ssm项目乱码问题"></a>ssm项目乱码问题</h1><h2 id="全局修改输出为UTF-8编码"><a href="#全局修改输出为UTF-8编码" class="headerlink" title="全局修改输出为UTF-8编码"></a>全局修改输出为UTF-8编码</h2><ol><li>xml 方法<br><a href="https://link.jianshu.com/?t=http://littleduke.blog.51cto.com/7205987/1340002">sxhjhf - springMVC @response 中文乱码解决</a></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- utf-8编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>annotation方法<br>由方法1, 我们可以看到一个起关键作用的类<code>org.springframework.http.converter.StringHttpMessageConverter</code>. 打开源码可以发现:</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractHttpMessageConverter</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 省略 ....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">&quot;ISO-8859-1&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Charset&gt; availableCharsets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> writeAcceptCharset = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringHttpMessageConverter</span><span class="params">(Charset defaultCharset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(defaultCharset, MediaType.TEXT_PLAIN, MediaType.ALL);</span><br><span class="line">        <span class="keyword">this</span>.availableCharsets = <span class="keyword">new</span> ArrayList&lt;Charset&gt;(Charset.availableCharsets().values());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 默认编码已经被设定为了<code>Charset.forName(&quot;ISO-8859-1&quot;)</code>. 所以我们需要想办法替换掉这个默认编码. 方法1是通过<code>xml</code>加载了参数为<code>UTF-8</code>的<code>StringHttpMessageConverter</code>.<br> 回到使用注解配置的Java代码中:<br> 因为配置SpringMVC的类, 需要继承于<code>WebMvcConfigurerAdapter</code>, 我们可以看看里面有没有相关方法可用.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 所以继续看WebMvcConfigurer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Configure the &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;s to use for reading or writing</span></span><br><span class="line"><span class="comment">     * to the body of the request or response. If no converters are added, a</span></span><br><span class="line"><span class="comment">     * default list of converters is registered.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that adding converters to the list, turns off</span></span><br><span class="line"><span class="comment">     * default converter registration. To simply add a converter without impacting</span></span><br><span class="line"><span class="comment">     * default registration, consider using the method</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #extendMessageConverters(java.util.List)&#125; instead.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters initially an empty list of converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A hook for extending or modifying the list of converters after it has been</span></span><br><span class="line"><span class="comment">     * configured. This may be useful for example to allow default converters to</span></span><br><span class="line"><span class="comment">     * be registered and then insert a custom converter through this method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters the list of configured converters to extend.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 4.1.3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>configureMessageConverters</code>和<code>extendMessageConverters</code>两个方法. 区别是前者会覆盖掉默认的<code>Converter</code>, 而后者是扩展. 所以我们只需要在我们继承于<code>WebMvcConfigurerAdapter</code>这个类的实现中覆盖掉<code>configureMessageConverters</code>方法即可.<br> 实现如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;me.xiaofud.spring101.spittr.web&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        StringHttpMessageConverter stringHttpMessageConverter = <span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        stringHttpMessageConverter.setWriteAcceptCharset(<span class="keyword">false</span>);</span><br><span class="line">        converters.add(stringHttpMessageConverter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">curl -I -X POST <span class="string">&quot;http://localhost:8080/app/post/add&quot;</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Server: Apache-Coyote/<span class="number">1.1</span></span><br><span class="line">Content-<span class="built_in">Type</span>: text/plain;charset=UTF<span class="number">-8</span></span><br><span class="line">Content-Length: <span class="number">1338</span></span><br><span class="line">Date: Sun, <span class="number">12</span> Nov <span class="number">2017</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">49</span> GMT</span><br></pre></td></tr></table></figure><h2 id="修改读取参数时候的编码"><a href="#修改读取参数时候的编码" class="headerlink" title="修改读取参数时候的编码"></a>修改读取参数时候的编码</h2><p>在<code>web.xml</code>中:<br> 添加一个filter, 注册<code>org.springframework.web.filter.CharacterEncodingFilter</code>.</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span> </span><br></pre></td></tr></table></figure><h1 id="jsp中文乱码问题"><a href="#jsp中文乱码问题" class="headerlink" title="jsp中文乱码问题"></a>jsp中文乱码问题</h1><p>Java的内核和class文件是基于unicode的，这使Java程序具有良好的跨平台性，但也带来了一些中文乱码问题的麻烦。原因主要有两方面，Java和JSP文件本身编译时产生的乱码问题和Java程序于其他媒介交互产生的乱码问题。首先Java（包括JSP）源文件中很可能包含有中文，而Java和JSP源文件的保存方式是基于字节流的，如果Java和JSP编译成class文件过程中，使用的编码方式与源文件的编码不一致，就会出现乱码。基于这种乱码，建议在Java文件中尽量不要写中文（注释部分不参与编译，写中文没关系），如果必须写的话，尽量手动带参数－ecoding GBK或－ecoding gb2312或－ecoding UTF-8编译；对于JSP，在文件头加上</p><p>&lt;%@ page contentType=”text/html;charset=GBK”%&gt;或</p><p>&lt;%@ page contentType=”text/html;charset=gb2312”%&gt;基本上就能解决这类乱码问题。</p><p><strong>下面是一些常见中文乱码问题的解决方法（</strong>下面例子中ecoding采用的是gb2312，也可设为ecoding GBK或ecoding UTF-8<strong>）：</strong></p><h2 id="一、-JSP页面乱码"><a href="#一、-JSP页面乱码" class="headerlink" title="一、 JSP页面乱码"></a>一、 JSP页面乱码</h2><p>这种乱码问题比较简单，一般是页面编码不一致导致的乱码，一般新手容易出现这样的问题，具体分以下两种情况：</p><p>Ø <strong>未指定使用字符集编码</strong></p><p>下面的显示页面(display.jsp)就出现乱码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%out.print(&quot;JSP的中文处理&quot;);%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种乱码的原因是没有在页面里指定使用的字符集编码，JSP页面中出现了中文字符，而默认的ISO-8859-1字符集中无中文字符，解决方法：只要在页面开始地方用下面代码指定字符集编码即可，在JSP页面中指定编码方式(gb2312),和浏览器解码方式设置相同，即在页面的第一行加上：</p><p>&lt;%@ page contentType=”text/html; charset=gb2312”%&gt;，就可以消除乱码了。</p><p>完整页面如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%out.print(&quot;JSP的中文处理&quot;);%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Ø <strong>编码字符集设置不一致</strong></p><p>下面的显示页面(display.jsp)就出现乱码：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> pageEncoding=<span class="string">&quot;gb2312&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=iso8859-1&quot;</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;JSP的中文处理&lt;/title&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html charset=gb2312&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%out.print(<span class="string">&quot;JSP的中文处理&quot;</span>);%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这个出现乱码原因是由于页面编码不一致导致的乱码，在这个例子中我们可以看到有三处设置字符集的地方，下面分别了解一下这三处设置具体含义：</p><p><strong>第一处&lt;%@ page language=”java” pageEncoding=”gb2312”%&gt;的编码格式为jsp文件的存储格式。Eclipse会根据这个编码格式保存文件。并编译jsp文件，包括里面的汉字。</strong><br><strong>第二处编码为解码格式。因为存为gb2312的文件被解码为iso8859-1，这样如有中文肯定出乱码。也就是必须一致。而第二处所在的这一行，可以没有。缺省也是使用iso8859-1的编码格式。所以如果没有这一行的话，也会出现乱码。必须一致才可以</strong>。</p><p><strong>第三处编码为控制浏览器的解码方式。如果前面的解码都一致并且无误的话，这个编码格式用不用设置都可以。有的网页出现乱码，就是因为浏览器不能确定使用哪种编码格式。因为页面有时候会嵌入页面，导致浏览器混淆了编码格式出现了乱码。</strong></p><p>完整解决代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;gb2312&quot;%&gt;</span><br><span class="line">&lt;%@ page contentType=&quot;text/html;charset= gb2312&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%out.print(&quot;JSP的中文处理&quot;);%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、-表单提交中文时出现乱码"><a href="#二、-表单提交中文时出现乱码" class="headerlink" title="二、 表单提交中文时出现乱码"></a><strong>二、</strong> 表单提交中文时出现乱码</h2><p>下面是一个提交页面(submit.jsp)，代码如下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;form1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post/get&quot;</span> <span class="attr">action</span>=<span class="string">&quot;process.jsp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是处理页面(process.jsp)代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%=request.getParameter(&quot;name&quot;)%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果submit.jsp提交英文字符能正确显示，如果提交中文时就会出现乱码。原因：浏览器默认使用UTF-8编码方式来发送请求，而UTF- 8和GB2312编码方式表示字符时不一样，这样就出现了不能识别字符。</p><p>Ø <strong>POST****提交方式</strong></p><p>解决办法:</p><p>A、 接受参数时进行编码转换</p><p>String s=new String(request.getParameter(“name”).getBytes(“ISO-8859-1”),”gb2312”) ;</p><p>修改后的process.jsp代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%</span><br><span class="line">String s=new String(request.getParameter(&quot;name&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;gb2312&quot;);</span><br><span class="line">out.print(s);</span><br><span class="line">%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用该方法的话，每一个参数都必须这样进行转码。很麻烦。但确实可以拿到汉字。</p><p>B、通过request.seCharacterEncoding (“gb2312”)对请求进行统一编码，就实现了中文的正常显示。</p><p>修改后的process.jsp代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line">&lt;%request.seCharacterEncoding(&quot;gb2312&quot;);%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%=request.getParameter(&quot;name&quot;)%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用该方法接受此参数的页面就不必在转码了，即可得到汉字参数。但每页都需要执行这句话。</p><p>C、为了避免每页都要写request.setCharacterEncoding(“gb2312”)，可以使用过滤器对所有jsp</p><p>进行编码处理。就是使用Servlet规范中的过虑器指定编码，主要代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter; </span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain; </span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException; </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest; </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetCharacterEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String encoding = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.encoding = <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.encoding = filterConfig.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span>&#123;</span><br><span class="line">        request.setCharacterEncoding(encoding);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=&quot;</span>+encoding);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器在web.xml中的配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SetCharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>SetCharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>gb2312<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>SetCharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改后的process.jsp代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%=request.getParameter(&quot;name&quot;)%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上方法只对POST方式提交有效果。</p><p>Ø <strong>GET****提交方式</strong></p><p>如果使用get方式提交中文，接受参数的页面也会出现乱码，这个乱码的原因也是tomcat的内部编码格式iso8859-1导致。Tomcat会以get的缺省编码方式iso8859-1对汉字进行编码，编码后追加到url，导致接受页面得到的参数为乱码。</p><p>解决办法：</p><p>A、 使用POST提交方式解决办法的第一种方式，对接受到的字符进行解码，再转码。</p><p>B 、首先配置tomcat下server.xml的Connector节点增加useBodyEncodingForURI=”true”属性配置，然后在JSP页面中加入&lt;%request.seCharacterEncoding(“gb2312”);%&gt;所设置的编码格式进行编码。</p><p>1、Tomcat中server.xml配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">useBodyEncodingForURI</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>2、修改后的process.jsp代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html; charset=gb2312&quot;%&gt;</span><br><span class="line">&lt;%request.seCharacterEncoding(&quot;gb2312&quot;);%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>JSP的中文处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&lt;%=request.getParameter(&quot;name&quot;)%&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、数据库连接出现乱码"><a href="#三、数据库连接出现乱码" class="headerlink" title="三、数据库连接出现乱码"></a>三、数据库连接出现乱码</h2><p>这种乱码会使你插入数据库的中文变成乱码，或者读出显示时也是乱码，解决方法如下：　　</p><p>在数据库连接字符串中加入编码字符集　</p><p>String Url=” jdbc:sqlserver://localhost:1433; DataBaseName=mydb;user=sa&amp;password=sa&amp;useUnicode=true&amp;characterEncoding=GB2312”;　</p><p>并在JSP页面中使用如下代码：　</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=gb2312&quot;</span>);　　request.setCharacterEncoding(<span class="string">&quot;gb2312&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="四、关于jsp在MyEclipse中打开的乱码问题"><a href="#四、关于jsp在MyEclipse中打开的乱码问题" class="headerlink" title="四、关于jsp在MyEclipse中打开的乱码问题"></a>四、关于jsp在MyEclipse中打开的乱码问题</h2><p>对于一个已经存在的项目，Jsp文件的存储格式可能是utf-8。如果新安装的eclipse，则缺省打开使用的编码格式可能iso8859-1。所以导致 jsp里面的汉字出现乱码。这个乱码鱼解决方式如下：</p><p>A、Myeclispe Window - &gt; Preferences弹出属性窗口</p><p>General - &gt; Workspace 设置Text file encoding 全局设置。</p><p>B、右键你的项目—属性—Text file encoding 项目设置</p><p>**五、关于html页面在clipse中打开出现乱码情况</p><p>由于大部分页面都是由dreamweaver制作，其存储格式跟eclipse的识别有差别导致。</p><p>一般这种情况，在eclipse中新建一个jsp，直接从dreamweaver复制页面内容粘贴到jsp即可。</p><p><strong>六、<strong><strong>JSP</strong></strong>页面通过<strong><strong>URL</strong></strong>传递中文参数的乱码问题</strong></p><p>在项目中，我们经常遇到需要在jsp页面切换中传递中文字符。例如：<a href="http://website/test1.jsp?act=add&amp;type=%E8%8B%B9%E6%9E%9C">http://website/test1.jsp?act=add&amp;type=苹果</a></p><p>Ø 一般来说我们很少直接在URL里面把参数写成中文，如例子中的”type=苹果”这样传递。如果出现这种情况，在我们的接收参数的页面我们只需要做个简单的转换就可以了。</p><p>代码test1.jsp：(主要部分)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String type = request.getParameter(&quot;type&quot;);</span><br><span class="line">    String result = new String(type.getBytes(&quot;iso-8859-1&quot;), &quot;gb2312&quot;);</span><br><span class="line">    out.println(result);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>Ø 更普遍的做法，就是对url中的中文字符进行编码，变成类似type=%20D%20B这样的字符。</p><p>代码MyJsp1.jsp：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page import=&quot;java.net.*&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;./MyJsp2.jsp?act=&lt;%=URLEncoder.encode(&quot;中国人 非常好&quot;)%&gt;&#x27;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码MyJsp2.jsp:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.net.*&quot; %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String tempVal = URLDecoder.decode(request.getParameter(&quot;act&quot;));</span><br><span class="line">out.println(new String(tempVal.getBytes(&quot;ISO-8859-1&quot;), &quot;gb2312&quot;));</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="如果JS中的中文编码返回到JSP中，出现编码错误，进行如下修改"><a href="#如果JS中的中文编码返回到JSP中，出现编码错误，进行如下修改" class="headerlink" title="如果JS中的中文编码返回到JSP中，出现编码错误，进行如下修改"></a>如果JS中的中文编码返回到JSP中，出现编码错误，进行如下修改</h1><p>在web.xml中添加</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>HtmlConfiguration<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JspConfiguration<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>JsConfiguration<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.js<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="使用FreeMarker导出固定格式word文档"><a href="#使用FreeMarker导出固定格式word文档" class="headerlink" title="使用FreeMarker导出固定格式word文档"></a>使用FreeMarker导出固定格式word文档</h1><p><strong>一.下载FreeMarker的jar包</strong></p><p>下载地址：<a href="http://freemarker.org/freemarkerdownload.html%EF%BC%8C%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%8A%A5%E9%94%99%E7%9A%84%E8%87%AA%E8%A1%8C%E6%90%9C%E7%B4%A2%E7%BC%BA%E5%B0%91%E7%9A%84jar%E5%8C%85%E3%80%82">http://freemarker.org/freemarkerdownload.html，导入项目，报错的自行搜索缺少的jar包。</a></p><p><strong>二.修改word文档</strong></p><p>将需要替换的使用freemarker的占位符替换，类似EL表达式，不同是的对于循环遍历，if判断，freemarker有自己的格式。对于需要对list遍历生成的，word文档里使用参变量，后面在xml文件里额外定义参变量。修改后的具体格式如下：</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191821967.png" alt="image-20210324191821967"></p><p><strong>三.将修改后的word文档保存成xml格式</strong></p><p>使用word编辑好后，保存文档，将文档另存为xml格式，具体如下图：</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191803305.png" alt="image-20210324191803305"></p><p><strong>四.使用编辑工具打开xml，修改被分割的占位符</strong></p><p>使用notepad或者VSCode打开xml文档，将占位符被分割的，删除中间的word标签，只有完整占位符才会被freemarker解析。</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191745880.png" alt="image-20210324191745880"></p><p><strong>五.对于集合元素</strong></p><p>首先在xml中，需要确定循环的具体循环体，防止循环结果错误，找到正确循环体后，在头和尾部额外插入标签。<code>&lt;#list 集合 as 参数名&gt; &lt;/#list &gt;</code>，具体效果如下：</p><ol><li>需要循环生成选出的人员名+空格，而不是一整行。<code>&lt;w:p&gt;</code>代表一行</li></ol><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191718999.png" alt="image-20210324191718999"></p><ol start="2"><li>需要循环一行生成人员名。&lt;w:tr&gt;代表一个表格tr</li></ol><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191702736.png" alt="image-20210324191702736"></p><p>六.将修改好的xml文档，保存后，直接修改文件名，保存成resume.ftl<br>需要修改后缀名，window询问是否保存，点击是，即可。</p><p>七.创建导出工具类<br>将上一步生产的resume.ftl文件，复制到工具包下，创建工具类用于导出word，直接复制如下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yh.common.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;  </span><br><span class="line"><span class="keyword">import</span> java.io.Writer;  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map; </span><br><span class="line"><span class="keyword">import</span> freemarker.template.Configuration;  </span><br><span class="line"><span class="keyword">import</span> freemarker.template.Template;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Configuration configuration = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Template&gt; allTemplates = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">static</span> &#123;  </span><br><span class="line">        configuration = <span class="keyword">new</span> Configuration();  </span><br><span class="line">        configuration.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">        configuration.setClassForTemplateLoading(WordGenerator.class, <span class="string">&quot;/com/yh/common/util&quot;</span>);  </span><br><span class="line">        allTemplates = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// Java 7 钻石语法  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            allTemplates.put(<span class="string">&quot;resume&quot;</span>, configuration.getTemplate(<span class="string">&quot;resume.ftl&quot;</span>));  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WordGenerator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">createDoc</span><span class="params">(Map&lt;?, ?&gt; dataMap, String type)</span> </span>&#123;  </span><br><span class="line">        String name = <span class="string">&quot;temp&quot;</span> + (<span class="keyword">int</span>) (Math.random() * <span class="number">100000</span>) + <span class="string">&quot;.doc&quot;</span>;  </span><br><span class="line">        File f = <span class="keyword">new</span> File(name);  </span><br><span class="line">        Template t = allTemplates.get(type);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">  <span class="comment">// 这个地方不能使用FileWriter因为需要指定编码类型否则生成的Word文档会因为有无法识别的编码而无法打开 </span></span><br><span class="line">            Writer w = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(f), <span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            t.process(dataMap, w);  </span><br><span class="line">            w.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">            ex.printStackTrace();  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>八.控制层写法<br>    开发时，使用的struct，提供struct的写法。其中父类中包括了获取response和request的方法，这边可以在方法参数里面添加，读者根据具体情况自行修改。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">exportWord</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> ServletException, IOException </span>&#123; </span><br><span class="line">            HttpServletResponse resp = ServletActionContext.getResponse();</span><br><span class="line">request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(); </span><br><span class="line">        <span class="comment">//查询评审场次信息</span></span><br><span class="line">        List list1 = ?;</span><br><span class="line">        <span class="keyword">if</span>(!ValidateUtil.isEmpty(list1))&#123;</span><br><span class="line">            map.put(<span class="string">&quot;list1&quot;</span>, list1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查询轮次信息</span></span><br><span class="line">        map.put(<span class="string">&quot;round&quot;</span>, ?);</span><br><span class="line"></span><br><span class="line">        List list2 = ?;</span><br><span class="line">        <span class="keyword">if</span>(!ValidateUtil.isEmpty(list2))&#123;</span><br><span class="line">            map.put(<span class="string">&quot;list2&quot;</span>, list2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List list3 = ?;</span><br><span class="line">        <span class="keyword">if</span>(!ValidateUtil.isEmpty(list3))&#123;</span><br><span class="line">            map.put(<span class="string">&quot;list3&quot;</span>, list3);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//投票产生的人数</span></span><br><span class="line">        String expertNumber= ?;</span><br><span class="line">        map.put(<span class="string">&quot;expertNumber&quot;</span>, expertNumber);</span><br><span class="line">        <span class="comment">//总人数</span></span><br><span class="line">        String number = ?;</span><br><span class="line">        map.put(<span class="string">&quot;number&quot;</span>, number);</span><br><span class="line">        String filename = ？;<span class="comment">//可以是中文</span></span><br><span class="line">        <span class="comment">// 提示：在调用工具类生成Word文档之前应当检查所有字段是否完整  </span></span><br><span class="line">        <span class="comment">// 否则Freemarker的模板殷勤在处理时可能会因为找不到值而报错 这里暂时忽略这个步骤了  </span></span><br><span class="line">        File file = <span class="keyword">null</span>;  </span><br><span class="line">        InputStream fin = <span class="keyword">null</span>;  </span><br><span class="line">        ServletOutputStream out = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 调用工具类WordGenerator的createDoc方法生成Word文档  </span></span><br><span class="line">            file = WordGenerator.createDoc(map, <span class="string">&quot;resume&quot;</span>);  </span><br><span class="line">            fin = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"></span><br><span class="line">            resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            resp.setContentType(<span class="string">&quot;application/msword&quot;</span>);  </span><br><span class="line">            <span class="comment">// 设置浏览器以下载的方式处理该文件默认名为filename.doc  </span></span><br><span class="line">            String fileName = <span class="string">&quot;attachment; filename= &quot;</span>+<span class="keyword">new</span> String(filename.getBytes(), <span class="string">&quot;ISO-8859-1&quot;</span>)+<span class="string">&quot;.doc&quot;</span>;<span class="comment">//转化中文，防止中文文件名导致下载文件文件名异常或者没有后缀名</span></span><br><span class="line">            resp.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, fileName);  </span><br><span class="line"></span><br><span class="line">            out = resp.getOutputStream();  </span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];  <span class="comment">// 缓冲区  </span></span><br><span class="line">            <span class="keyword">int</span> bytesToRead = -<span class="number">1</span>;  </span><br><span class="line">            <span class="comment">// 通过循环将读入的Word文件的内容输出到浏览器中  </span></span><br><span class="line">            <span class="keyword">while</span>((bytesToRead = fin.read(buffer)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">                out.write(buffer, <span class="number">0</span>, bytesToRead);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span>(fin != <span class="keyword">null</span>) fin.close();  </span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>) out.close();  </span><br><span class="line">            <span class="keyword">if</span>(file != <span class="keyword">null</span>) file.delete(); <span class="comment">// 删除临时文件  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>九.jsp写法<br>页面调用一个同步方法，到控制层即可导出文件。</p><p>10.生成效果</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324180157018.png" alt="image-20210324180157018"></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="SpringMVC, 随笔" scheme="https://wllshdx.github.io/tags/SpringMVC-%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>swagger</title>
    <link href="https://wllshdx.github.io/2021/03/24/swagger/"/>
    <id>https://wllshdx.github.io/2021/03/24/swagger/</id>
    <published>2021-03-24T09:56:50.000Z</published>
    <updated>2021-03-25T03:28:11.776Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><pre><code>swagger是有两个版本的，而且区别还挺大的，一个是**swagger-ui**也就是**swagger1**;还有一个是**springfox-swagger**也就是**swagger2**</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="添加-Swagger-依赖"><a href="#添加-Swagger-依赖" class="headerlink" title="添加 Swagger 依赖"></a>添加 Swagger 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- 集成 Swagger UI --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h3><p>Springfox 提供了一个 Docket 对象，让我们可以灵活的配置 Swagger 的各项属性。下面我们新建一个 cn.itweknow.sbswagger.conf.SwaggerConfig.java 类，并增加如下内容:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: <code>@Configuration</code> 是告诉 Spring Boot 需要加载这个配置类，<code>@EnableSwagger2</code> 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了。</p><h3 id="SwaggerUI访问"><a href="#SwaggerUI访问" class="headerlink" title="SwaggerUI访问"></a>SwaggerUI访问</h3><p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> 就可以看到如下的效果了</p><h3 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h3><ol><li><p>通过在控制器类上增加<code>@Api</code> 注解，可以给控制器增加描述和标签信息。</p></li><li><p>通过在接口方法上增加 <code>@ApiOperation</code> 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</p></li><li><p>实体描述，我们可以通过<code> @ApiModel</code> 和 <code>@ApiModelProperty</code> 注解来对我们 API 中所涉及到的对象做描述。</p></li><li><p>文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 <code>Docket.appInfo()</code> 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">api</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">    .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">            <span class="string">&quot;Spring Boot 项目集成 Swagger 实例文档&quot;</span>,</span><br><span class="line">            <span class="string">&quot;我的博客网站：https://itweknow.cn，欢迎大家访问。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;API V1.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Terms of service&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> Contact(<span class="string">&quot;名字想好没&quot;</span>, <span class="string">&quot;https://itweknow.cn&quot;</span>, <span class="string">&quot;gancy.programmer@gmail.com&quot;</span>),</span><br><span class="line">                <span class="string">&quot;Apache&quot;</span>, <span class="string">&quot;http://www.apache.org/&quot;</span>, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h3><p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 <code>@ApiIgnore</code> 注解，另一种是在 Docket 上增加筛选。</p><ol><li><p><code>@ApiIgnore</code> 注解。</p><p>如果想在文档中屏蔽掉删除用户的接口（user/delete），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</p></li><li><p>在 Docket 上增加筛选。Docket 类提供了 <code>apis()</code> 和 <code>paths()</code>两 个方法来帮助我们在不同级别上过滤接口：</p><ul><li><p><code>apis()</code>：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</p></li><li><p><code>paths()</code>：这种方式可以通过筛选 API 的 url 来进行过滤。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.itweknow.sbswagger.controller&quot;</span>))</span><br><span class="line">.paths(Predicates.or(PathSelectors.ant(<span class="string">&quot;/user/add&quot;</span>),</span><br><span class="line">        PathSelectors.ant(<span class="string">&quot;/user/find/*&quot;</span>)))</span><br></pre></td></tr></table></figure></li></ol><h3 id="自定义响应消息"><a href="#自定义响应消息" class="headerlink" title="自定义响应消息"></a>自定义响应消息</h3><ol><li><p>Swagger 允许我们通过 Docket 的 <code>globalResponseMessage()</code> 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 <code>useDefaultResponseMessages</code> 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(<span class="keyword">false</span>)</span><br><span class="line">.globalResponseMessage(RequestMethod.GET, newArrayList(</span><br><span class="line"><span class="keyword">new</span> ResponseMessageBuilder()</span><br><span class="line">              .code(<span class="number">500</span>)</span><br><span class="line">              .message(<span class="string">&quot;服务器发生异常&quot;</span>)</span><br><span class="line">              .responseModel(<span class="keyword">new</span> ModelRef(<span class="string">&quot;Error&quot;</span>))</span><br><span class="line">              .build(),</span><br><span class="line">       <span class="keyword">new</span> ResponseMessageBuilder()</span><br><span class="line">              .code(<span class="number">403</span>)</span><br><span class="line">              .message(<span class="string">&quot;资源不可用&quot;</span>)</span><br><span class="line">              .build()</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>添加如上面的代码后，如下图所示，您会发现在 SwaggerUI 页面展示的所有 GET 类型请求的 403 以及 500 错误的响应消息都变成了我们自定义的内容。</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175730657.png" alt="image-20210324175730657"></p></li></ol><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h3 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h3><p><code>@Api</code>: 可设置对控制器的描述。</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191541219.png" alt="image-20210324191541219"></p><h3 id="接口相关注解"><a href="#接口相关注解" class="headerlink" title="接口相关注解"></a>接口相关注解</h3><ol><li><p><code>@ApiOperation</code>: 可设置对接口的描述。</p></li><li><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191519288.png" alt="image-20210324191519288"></p></li><li><p><code>@ApiIgnore</code>: Swagger 文档不会显示拥有该注解的接口。</p></li><li><p><code>@ApiImplicitParams</code>: 用于描述接口的非对象参数集。</p></li><li><p><code>@ApiImplicitParam</code>: 用于描述接口的非对象参数，一般与 <code>@ApiImplicitParams</code> 组合使用。</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324191457067.png" alt="image-20210324191457067"></p></li></ol><h3 id="Model-相关注解"><a href="#Model-相关注解" class="headerlink" title="Model 相关注解"></a>Model 相关注解</h3><ol><li><code>@ApiModel</code>: 可设置接口相关实体的描述。</li><li><code>@ApiModelProperty</code>: 可设置实体属性的相关描述。</li><li><img src="../../../../../../Desktop/%E7%AC%94%E8%AE%B0/images/image-20200510163134396.png" alt="image-20200510163134396"></li></ol><h2 id="Swagger-UI-的使用"><a href="#Swagger-UI-的使用" class="headerlink" title="Swagger UI 的使用"></a>Swagger UI 的使用</h2><h3 id="接口查看"><a href="#接口查看" class="headerlink" title="接口查看"></a>接口查看</h3><p>SwaggerUI 会以列表的方式展示所有扫描到的接口，初始状态是收缩的，我们只需要点击展开就好，而且会在左边标识接口的请求方式（GET、POST、PUT、DELETE 等等）。</p><h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p>如下图所示，点击接口展开后页面右上角的 <strong>Try it out</strong> 按钮后，页面会变成如图所示：</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175753177.png" alt="image-20210324175753177"></p><p>SwaggerUI 会给我们自动填充请求参数的数据结构，我们需要做的只是点击 <strong>Execute</strong> 即可发起调用</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175807940.png" alt="image-20210324175807940"></p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>如下图所示，SwaggerUI 会通过我们在实体上使用的 <code>@ApiModel</code> 注解以及<code>@ApiModelProperty</code> 注解来自动补充实体以及其属性的描述和备注。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：</p><ul><li> Swagger Editor：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</li><li> Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</li><li> Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。</li><li>跨语言性，支持 40 多种语言。</li><li>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</li><li>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="swagger" scheme="https://wllshdx.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>redis-springboot</title>
    <link href="https://wllshdx.github.io/2021/03/24/redis-springboot/"/>
    <id>https://wllshdx.github.io/2021/03/24/redis-springboot/</id>
    <published>2021-03-24T09:35:06.000Z</published>
    <updated>2021-03-25T03:13:10.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis 是一种运行在内存的数据库，支持7 种数据类型的存储。Redis 是一个开源、使用ANSIC语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、键值数据库，并提供多种语言的APl 。 Redis 是基于内存的，</p><h1 id="Spring-Boot-整合-Redis"><a href="#Spring-Boot-整合-Redis" class="headerlink" title="Spring Boot 整合 Redis"></a>Spring Boot 整合 Redis</h1><p>​    Spring 提供了一个RedisConnectionFactory 接口， 通过它可以生成一个RedisConnection 接口对象，而RedisConnection 接口对象是对Redis 底层接口的封装。例如，使用Jedis 驱动，那么Spring就会提供RedisConnection 接口的实现类JedisConnection 去封装原有的Jedis ( redis.clients.jedis.Jedis )对象。</p><p><strong>他们的类的关系：</strong></p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324174855935.png" alt="image-20210324174855935"></p><p>在Spring 中是通过RedisConnection 接口操作Redis 的，而RedisConnection则对原生的Jedis 进行封装。要获取RedisConnection 接口对象， 是通过RedisConnectionFactory 接口去生成的，所以第一步要配置的便是这个工厂了，而<strong>配置这个工厂主要是配置Redis 的连接池</strong>，对于连接池可以限定其最大连接数、超时时间等属性。</p><p>Spring 为了进一步简化开发，提供了RedisTemplate。</p><h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a><strong>RedisTemplate</strong></h2><p>RedisTemplate是一个强大的类，首先它会自动从RedisConnectionFactory 工厂中获取连接，然后执行对应的Redis命令，在<strong>最后还会关闭Redis 的连接</strong>。这些在RedisTemplate 中都被封装了，所以并不需要开发者关注Redis 连接的闭合问题。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RedisTemplate&lt;Object , Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">redisTemplate.setConnectionFactory(initConnectionFactory()) ;</span><br></pre></td></tr></table></figure><p>Redis 存入的并不是”key1”这样的字符串，这是怎么回事呢？首先需要清楚的是， Redis是一种基于字符串存储的NoSQL ， 而Java 是基于对象的语言，对象是无法存储到Redis 中的，不过Java 是基于对象的语言，对象是无法存储到Redis 中的，不过Java提供了序列化机制，只要类实现了java .io.Serializable 接口， 就代表类的对象能够进行序列化，通过将类对象进行序列化就能够得到二进制字符串，这样Red is 就可以将这些类对象以字符串进行存储。<br>    Java 也可以将那些二进制字符串通过反序列化转为对象，通过这个原理， Spring 提供了序列化器的机制，并且实现了几个序列化器，其设计如图：</p><p><img src="../../../../../../Desktop/%E7%AC%94%E8%AE%B0/images/image-20200509130832771.png" alt="image-20200509130832771"></p><p>​    对于序列化器， Spring 提供了RedisSerializer 接口，它有两个方法。这两个方法，一个是serialize ， 它能把那些可以序列化的对象转换为二进制字符串；另一个是deserialize,它能够通过反序列化把二进制字符串转换为Java 对象。JacksonJsonRedisSerializer 因为API 过时，己经不推荐使用， 我们这里主要讨论StringRedisSerializer 和JdkSerializationRedisSerializer,其中JdkSerializationRedisSerializer 是RedisTemplate 默认的序列化器</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324174941391.png" alt="image-20210324174941391"></p><p>如果我们什么都没有配置，因此它会默认使用JdkSerial izationRedisSerializer 对对象进行序列化和反序列化。这就是会产生复杂字符串的原因，只是这样使用会给我们查询Redis 数据带来很大的困难。为了克服这个困难，我们希望RedisTemplate 可以将Redis 的键以普通字符串保存。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name=&quot;redisTemplate&quot;）</span></span><br><span class="line"><span class="meta">public RedisTemplate&lt;Object , Object&gt; initRedisTemplate() &#123;</span></span><br><span class="line"><span class="meta">RedisTemplate&lt;Object , Object&gt; redisTemplate =new RedisTemplate&lt;&gt; ();</span></span><br><span class="line"><span class="meta">//RedisTemplate 会自动初始化StringRedisSerializer ，所以这里直接获取</span></span><br><span class="line"><span class="meta">RedisSerializer stringRedisSerializer = redisTemplate.getStringSerializer();</span></span><br><span class="line"><span class="meta">// 设置字符串序列化器，这样Spring 就会把Redis的key当作字符串处理了</span></span><br><span class="line"><span class="meta">redisTemplate.setKeySerializer(stringRedisSerializer);</span></span><br><span class="line"><span class="meta">redisTemplate.setHashKeySerializer(stringRedisSerializer);</span></span><br><span class="line"><span class="meta">redisTemplate.setHashValueSerializer(stringRedisSerializer);</span></span><br><span class="line"><span class="meta">redisTemplate.setConnectionFactory(initConnectionFactory());</span></span><br><span class="line"><span class="meta">return redisTemplate;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>Redis的键己经从复杂的编码变为简单的字符串了，而hash数据类型则全部采用了字符串的形式，这是因为我们设置了使用StringRedisSerializer 序列化器操作它们。</p><p><strong>细节：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;keyl&quot;</span>,<span class="string">&quot;valuel&quot;</span>);</span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;field&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure><p>上述的两个操作并不是在同一个Redis 的连接下完成的，首先在操作key1时， redisTemplate 会先从连接工厂（ RedisConnectionFactory ）中获取一个连接，然后执行对应的Redis 命令， 再关闭这条连接：其次在操作hash 时，它也是从连接工厂中获取另一条连接，然后执行命令，再关闭该连接。这样显然<strong>存在资源的浪费，我</strong>们更加希望的是在同一条连接中就执行两个命令。为了克服这个问题， Spring 为我们提供了<strong>RedisCallback</strong>和<strong>SessionCallback</strong>两个接口。</p><p>Redis 使用得最多的是字符串，因此在spring-data-redis 项目中，还提供了一个StringRedisTemplate类，这个类继承RedisTemplate ，只是提供了字符串的操作而己，对于复杂Java 对象还需要自行处理。</p><h2 id="Spring-对Redis数据类型操作的封装"><a href="#Spring-对Redis数据类型操作的封装" class="headerlink" title="Spring 对Redis数据类型操作的封装"></a><strong>Spring 对Redis数据类型操作的封装</strong></h2><p>Redis 能够支持7 种类型的数据结构，这7 种类型是字符串、散列、列表（链表） 、集合、有序集合、基数和地理位置。为此Spring 针对每一种数据结构的操作都提供了对应的操作接口</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175035458.png" alt="image-20210324175035458"></p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175059458.png" alt="image-20210324175059458"></p><p>​    这样就可以通过各类的操作接口来操作不同的数据类型了， 当然这需要你熟悉Redis的各种命令。有时我们可能需要对某一个键值对（ key-value ）做连续的操作，例如， 有时需要连续操作一个散列数据类型或者列表多次， 这时Spring 也提供支持，它提供了对应的BoundXXXOperations 接口，</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175127652.png" alt="image-20210324175127652"></p><p>​    同样地， RedisTemplate 也对获取它们提供了对应的方法</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175148303.png" alt="image-20210324175148303"></p><p>​    获取其中的操作接口后，我们就可以对某个键的数据进行多次操作，这样我们就知道如何有效地通过Spring 操作Redis 的各种数据类型了。</p><h2 id="SessionCallback-和RedisCallback"><a href="#SessionCallback-和RedisCallback" class="headerlink" title="SessionCallback 和RedisCallback"></a>SessionCallback 和RedisCallback</h2><p>​    <strong>SessionCallback 接口和RedisCallback 接口，它们的作用是让RedisTemplate 进行回调，通过它们可以在同一条连接下执行多个Redis 命令</strong></p><p>​    其中SessionCa!lback提供了良好的封装，对于开发者比较友好，因此在实际的开发中应该优先选择使用它；相对而言，RedisCallback 接口比较底层， 需要处理的内容也比较多，可读性较差，所以在非必要的时候尽量不选择使用它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要处理底层的转换规则，如果不考虑改写底层，尽量不使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useRedisCallback</span><span class="params">(RedisTemplate redisTemplate )</span> </span>&#123;</span><br><span class="line">redisTemplate.execute(<span class="keyword">new</span> RedisCallback () &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection rc)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">rc.set(<span class="string">&quot;key1&quot;</span>.getBytes(),<span class="string">&quot;valuel&quot;</span>.getBytes());</span><br><span class="line">rc.hSet(<span class="string">&quot;hash&quot;</span>.getBytes(), <span class="string">&quot;field&quot;</span>.getBytes(), <span class="string">&quot;hvalue&quot;</span>.getBytes());</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高级接口，比较友好， 一般情况下，优先使用它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useSessionCallback</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> SessionCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations ro)</span><span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        ro.opsForValue().set(<span class="string">&quot;keyl&quot;</span>,<span class="string">&quot;valuel&quot;</span>);</span><br><span class="line">        ro.opsForHash().put(”hash<span class="string">&quot;, &quot;</span>field<span class="string">&quot;,&quot;</span>hvalue<span class="string">&quot;);</span></span><br><span class="line"><span class="string">        return null;</span></span><br><span class="line"><span class="string">    ));</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​    RedisCallback 接口井不是那么友好， 但是它能够改写一些底层的东西，如序列化的问题， 所以在需要改写那些较为底层规则时， 可以使用它。使用SessionCallback 接口则比较友好,它提供了更为高级的API ， 使得我们的使用更为简单，可读性也更佳。</p><h1 id="SpringBoot和Redis使用"><a href="#SpringBoot和Redis使用" class="headerlink" title="SpringBoot和Redis使用"></a>SpringBoot和Redis使用</h1><h2 id="SpringBoot-缓存"><a href="#SpringBoot-缓存" class="headerlink" title="SpringBoot 缓存"></a>SpringBoot 缓存</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    Java缓存接口标准JSR-107：Java Caching定义了5个核心接口，分别是<strong>CachingProvider（缓存提供者）, CacheManager（缓存管理器）, Cache（缓存组件）, Entry （key-value对）和Expiry（条目有效期）</strong>，他们的关系如下图所示。但是该缓存规范，整合难度较大。Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；    </p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175217807.png" alt="image-20210324175217807"></p><h2 id="接口、缓存注解、key-value生成策略"><a href="#接口、缓存注解、key-value生成策略" class="headerlink" title="接口、缓存注解、key/value生成策略"></a>接口、缓存注解、key/value生成策略</h2><table><thead><tr><th>Cache</th><th>缓存接口，定义缓存操作。实现：RedisCache、EhCache等（根据缓存技术不同来实现Cache接口）</th></tr></thead><tbody><tr><td>CacheManager</td><td>缓存接口，缓存管理器，管理各种缓存（Cache）组件</td></tr><tr><td>@Cacheable</td><td>可缓存的，标注方法，能够根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td>清空缓存</td></tr><tr><td>@CachePut</td><td>更新缓存</td></tr><tr><td>@EnableCaching</td><td>开启基于注解的缓存</td></tr><tr><td>keyGenerator</td><td>缓存数据时key生成策略</td></tr><tr><td>serialize</td><td>缓存数据时value序列化策略</td></tr></tbody></table><p>参考官方文档：</p><p><a href="https://docs.spring.io/spring/docs/5.1.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache">https://docs.spring.io/spring/docs/5.1.0.BUILD-SNAPSHOT/spring-framework-reference/integration.html#cache</a></p><h1 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h1><p><strong>a引入依赖</strong>[这里顺便将session保存到redis中。]</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot Data Cache 依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置redis参数"><a href="#配置redis参数" class="headerlink" title="配置redis参数"></a>配置redis参数</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##  redis config</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 最大空闲连接数</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 最小空闲连接数</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 等待可用连接的最大时间，负数为不限制</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 最大活跃连接数，负数为不限制</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 数据库连接超时时间，2.0 中该参数的类型为Duration，这里在配置的时候需要指明单位  1.x可以将此参数配置10000 单位是ms</span></span><br><span class="line"><span class="comment"># 连接池配置，2.0中直接使用jedis或者lettuce配置连接池</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">60s</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cache参数-很少用到"><a href="#cache参数-很少用到" class="headerlink" title="cache参数[很少用到]"></a>cache参数[很少用到]</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#缓存的名称集合，多个采用逗号分割</span></span><br><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#缓存的类型，官方提供了很多，这里我们填写redis</span></span><br><span class="line"><span class="meta">spring.cache.type</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#是否缓存null数据，默认是false</span></span><br><span class="line"><span class="meta">spring.cache.redis.cache-null-values</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#redis中缓存超时的时间，默认60000ms</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#缓存数据key是否使用前缀，默认是true</span></span><br><span class="line"><span class="meta">spring.cache.redis.use-key-prefix</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#缓存数据key的前缀，在上面的配置为true时有效，</span></span><br><span class="line"><span class="meta">spring.cache.redis.key-prefix</span>=<span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="RedisConfiguration"><a href="#RedisConfiguration" class="headerlink" title="RedisConfiguration"></a>RedisConfiguration</h2><p>采用代码的方式，只要需要配置的是<strong>CacheMananger</strong>，采用Redis时具体实现我们需要使用<strong>其子类RedisCacheMananger</strong>来做配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis缓存配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义redis key值生成策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyGenerator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(target.getClass().getName());</span><br><span class="line">                sb.append(method.getName());</span><br><span class="line">                <span class="keyword">for</span> (Object obj : params) &#123;</span><br><span class="line">                    sb.append(obj.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// data-redis 1.x形式</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;</span></span><br><span class="line"><span class="comment">//        RedisCacheManager redisCacheManager = new RedisCacheManager(redisTemplate);</span></span><br><span class="line"><span class="comment">//        return redisCacheManager;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * spring-data-redis  版本不同，方法也不一样 上面是1.5  下面是2.0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* @Bean</span></span><br><span class="line"><span class="comment">    public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;</span></span><br><span class="line"><span class="comment">        RedisCacheManager manager = new RedisCacheManager(redisTemplate);</span></span><br><span class="line"><span class="comment">        manager.setUsePrefix(true);</span></span><br><span class="line"><span class="comment">        RedisCachePrefix cachePrefix = new RedisPrefix(&quot;prefix&quot;);</span></span><br><span class="line"><span class="comment">        manager.setCachePrefix(cachePrefix);</span></span><br><span class="line"><span class="comment">        // 整体缓存过期时间</span></span><br><span class="line"><span class="comment">        manager.setDefaultExpiration(3600L);</span></span><br><span class="line"><span class="comment">        // 设置缓存过期时间。key和缓存过期时间，单位秒</span></span><br><span class="line"><span class="comment">        Map&lt;String, Long&gt; expiresMap = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">        expiresMap.put(&quot;user&quot;, 1000L);</span></span><br><span class="line"><span class="comment">        manager.setExpires(expiresMap);</span></span><br><span class="line"><span class="comment">        return manager;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义CacheManager  配置全局缓存时间  data-redis2.x配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public CacheManager cacheManager(RedisTemplate redisTemplate) &#123;</span></span><br><span class="line"><span class="comment">//        //全局redis缓存过期时间</span></span><br><span class="line"><span class="comment">//        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration</span></span><br><span class="line"><span class="comment">//                .defaultCacheConfig()</span></span><br><span class="line"><span class="comment">//                .entryTtl(Duration.ofHours(1));</span></span><br><span class="line"><span class="comment">//        RedisCacheWriter redisCacheWriter = RedisCacheWriter</span></span><br><span class="line"><span class="comment">//                .nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());</span></span><br><span class="line"><span class="comment">//        RedisCacheManager redisCacheManager = new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);</span></span><br><span class="line"><span class="comment">//        return redisCacheManager;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  data-redis 2.x配置  支持配置对应key缓存时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">// 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span></span><br><span class="line">        config = config.entryTtl(Duration.ofMinutes(<span class="number">30</span>))</span><br><span class="line">            <span class="comment">// 设置缓存的默认过期时间，也是使用Duration设置</span></span><br><span class="line">                .disableCachingNullValues();     <span class="comment">// 不缓存空值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置一个初始化的缓存空间set集合</span></span><br><span class="line">        Set&lt;String&gt; cacheNames =  <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cacheNames.add(<span class="string">&quot;device&quot;</span>);</span><br><span class="line">        cacheNames.add(<span class="string">&quot;project_type&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个缓存空间应用不同的配置</span></span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; configMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configMap.put(<span class="string">&quot;device&quot;</span>, config);</span><br><span class="line">        configMap.put(<span class="string">&quot;project_type&quot;</span>, config.entryTtl(Duration.ofHours(<span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 使用自定义的缓存配置初始化一个cacheManager</span></span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .initialCacheNames(cacheNames)</span><br><span class="line">                <span class="comment">// 注意这两句的调用顺序，一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span></span><br><span class="line">                .withInitialCacheConfigurations(configMap)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 防止redis入库序列化乱码的问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>     返回类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;Object, Object&gt;()</span></span>;</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//key序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class));</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开启缓存配置"><a href="#开启缓存配置" class="headerlink" title="开启缓存配置"></a>开启缓存配置</h2><p>这里把@EnableCaching、@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600 * 24)<br>配置在main主类上，也可以配置 在configuration的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.csii.dao&quot;)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600 * 24)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCsiiServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AppCsiiServerApplication.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        context=SpringApplication.run(AppCsiiServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis注解使用案例"><a href="#Redis注解使用案例" class="headerlink" title="Redis注解使用案例"></a>Redis注解使用案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sl.cache.service;</span><br><span class="line"><span class="keyword">import</span> com.sl.cache.entity.Product;</span><br><span class="line"><span class="keyword">import</span> com.sl.cache.mapper.ProductMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Caching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;product&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductMapper productMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;product1&quot;,key = &quot;#root.methodName+&#x27;[&#x27;+#id+&#x27;]&#x27;&quot;)</span></span><br><span class="line">    <span class="comment">//@Cacheable(cacheNames = &#123;&quot;product1&quot;,&quot;product2&quot;&#125;)// 默认key为参数，多个参数SimpleKey [arg1,arg2]</span></span><br><span class="line">    <span class="comment">//@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+&#x27;[&#x27;+#id+&#x27;]&#x27;&quot;)</span></span><br><span class="line">    <span class="comment">//@Cacheable(cacheNames = &quot;product&quot;,keyGenerator = &quot;myKeyGenerator&quot;)</span></span><br><span class="line">    <span class="comment">//@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+&#x27;[&#x27;+#id+&#x27;]&#x27;&quot;,condition=&quot;#a0&gt;10&quot;,unless = &quot;#a0==11&quot;) //或者condition=&quot;#id&gt;10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProductById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">       Product product =productMapper.getProductById(id);</span><br><span class="line">       System.out.println(product);</span><br><span class="line">       <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(value=&quot;product&quot;,key = &quot;#result.productId&quot;,condition = &quot;#result!=null&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Product <span class="title">updateProduct</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = productMapper.updateProduct(product);</span><br><span class="line">        System.out.println(<span class="string">&quot;影响行数：&quot;</span>+count);</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> product;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@CacheEvict(value=&quot;product&quot;,key=&quot;#id&quot;)</span></span><br><span class="line">    <span class="comment">//@CacheEvict(value=&quot;product&quot;,allEntries = true) //清楚所有缓存</span></span><br><span class="line">    <span class="meta">@CacheEvict(value=&quot;product&quot;,allEntries = true,beforeInvocation = true)</span> <span class="comment">//清楚所有缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteProductById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        productMapper.deleteProductById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//含有CachePut注解，所以执行这个方法时一定会查询数据库，及时有cacheable注解</span></span><br><span class="line">    <span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">            cacheable = &#123;@Cacheable(value=&quot;product&quot;,key=&quot;#productName&quot;)&#125;,</span></span><br><span class="line"><span class="meta">            put = &#123;</span></span><br><span class="line"><span class="meta">                    @CachePut(value=&quot;product&quot;,key=&quot;#result.productId&quot;),</span></span><br><span class="line"><span class="meta">                    @CachePut(value=&quot;product&quot;,key=&quot;#result.productName&quot;)</span></span><br><span class="line"><span class="meta">            &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Product <span class="title">getProductByName</span><span class="params">(String productName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Product product =productMapper.getProductByName(productName);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis注解使用—详细版"><a href="#Redis注解使用—详细版" class="headerlink" title="Redis注解使用—详细版"></a>Redis注解使用—详细版</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Service:将service加载到容器中</span></span><br><span class="line"><span class="comment">//CacheConfig:公共的缓存配置;cacheNames = &quot;emp&quot;:之后的value=&quot;emp&quot;就可以不用写</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;emp&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@Cacheable</span>：将方法的运行结果进行保存，以后再要相同的数据，直接从缓存中获取，不用调用方法</span></span><br><span class="line"><span class="comment">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，每个缓存组件有自己唯一的名字</span></span><br><span class="line"><span class="comment">     * 属性：（缓存数据时使用key-value的形式）</span></span><br><span class="line"><span class="comment">     *      cacheNames/value：指定缓存组件的名字；将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存</span></span><br><span class="line"><span class="comment">     *      key：缓存数据使用的key；可以用她来指定。默认是使用方法参数的值 键值对：1-方法的返回值</span></span><br><span class="line"><span class="comment">     *          参数id的值：#id相当于#root.args[0]</span></span><br><span class="line"><span class="comment">     *      keyGenerator：key的生成器；可以自己指定key的生成器组件id</span></span><br><span class="line"><span class="comment">     *          ——key和keyGenerator不可同时使用</span></span><br><span class="line"><span class="comment">     *      cacheManager：指定缓存管理器（从哪个缓存管理器中取）；cacheResolver：指定缓存解析器</span></span><br><span class="line"><span class="comment">     *      condition：指定符合条件的情况下才缓存；condition=&quot;#id&gt;0&quot;：id大于0的时候才缓存</span></span><br><span class="line"><span class="comment">     *      unless：否定缓存；当unless指定的true，方法的返回值就不会被缓存；可以获取到结果进行判断</span></span><br><span class="line"><span class="comment">     *          unless=&quot;#result == null&quot;:结果为空时不缓存</span></span><br><span class="line"><span class="comment">     *      sync：缓存是否使用异步模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &#123;&quot;emp&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmp</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询&quot;</span>+id+<span class="string">&quot;号员工&quot;</span>);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@CachePut</span>:既调用方法，又更新缓存数据；</span></span><br><span class="line"><span class="comment">     * 修改了数据库的某个数据，同时更新缓存</span></span><br><span class="line"><span class="comment">     * 运行过程：</span></span><br><span class="line"><span class="comment">     *  1、先调用目标方法</span></span><br><span class="line"><span class="comment">     *  2、将目标方法的结果缓存起来</span></span><br><span class="line"><span class="comment">     * 更新后重新查询出的数据是更新前的数据：</span></span><br><span class="line"><span class="comment">     *  ——（key默认使用方法参数的值）查询是的缓存是<span class="doctag">@Cacheable</span>缓存的值，key是1；<span class="doctag">@CachePut</span>更新后缓存的值：key是传入的employee对象</span></span><br><span class="line"><span class="comment">     *  ——所以要统一key：key=&quot;#employee.id&quot;;key=&quot;#result.id&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;emp&quot;,key=&quot;#employee.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">updateEmp</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *<span class="doctag">@CacheEvict</span>缓存清除</span></span><br><span class="line"><span class="comment">     * key：指定要清楚的数据</span></span><br><span class="line"><span class="comment">     * allEntries=true:指定清除这个缓存中的所有数据</span></span><br><span class="line"><span class="comment">     * beforeInvocation = false；缓存的清除是否在方法之前执行；false：在方法执行之后清除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CacheEvict(value=&quot;emp&quot;,key=&quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteEmp</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定多个缓存规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Caching(</span></span><br><span class="line"><span class="meta">        cacheable = &#123;</span></span><br><span class="line"><span class="meta">             @Cacheable(value = &quot;emp&quot;,key = &quot;#lastName&quot;)</span></span><br><span class="line"><span class="meta">        &#125;,</span></span><br><span class="line"><span class="meta">        put=&#123;</span></span><br><span class="line"><span class="meta">            @CachePut(value = &quot;emp&quot;,key=&quot;#result.id&quot;),</span></span><br><span class="line"><span class="meta">            @CachePut(value = &quot;emp&quot;,key = &quot;#result.email&quot;)</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeMapper.getEmpByLastName(lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot缓存实战-Redis-设置有效时间和自动刷新缓存"><a href="#Spring-Boot缓存实战-Redis-设置有效时间和自动刷新缓存" class="headerlink" title="Spring Boot缓存实战 Redis 设置有效时间和自动刷新缓存"></a>Spring Boot缓存实战 Redis 设置有效时间和自动刷新缓存</h2><h3 id="方式一：直接扩展注解的Value值"><a href="#方式一：直接扩展注解的Value值" class="headerlink" title="方式一：直接扩展注解的Value值"></a>方式一：直接扩展注解的Value值</h3><p>想在注解上直接配置过期时间和自动刷新时间，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(value = &quot;people#120#90&quot;, key = &quot;#person.id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">findOne</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    Person p = personRepository.findOne(person.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;为id、key为:&quot;</span> + p.getId() + <span class="string">&quot;数据做了缓存&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value属性上用#号隔开，第一个是原始的缓存容器名称，第二个是缓存的有效时间，第三个是缓存的自动刷新时间，单位都是秒。</p><p>缓存的有效时间和自动刷新时间支持SpEl表达式，支持在配置文件中配置</p><p><strong>例子2</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;people#$&#123;select.cache.timeout:1800&#125;#$&#123;select.cache.refresh:600&#125;&quot;, key = &quot;#person.id&quot;, sync = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">findOne</span><span class="params">(Person person, String a, String[] b, List&lt;Long&gt; c)</span> </span>&#123;</span><br><span class="line">    Person p = personRepository.findOne(person.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;为id、key为:&quot;</span> + p.getId() + <span class="string">&quot;数据做了缓存&quot;</span>);</span><br><span class="line">    System.out.println(redisTemplate);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：通过CacheManager配置（业务量不大推荐）"><a href="#方式二：通过CacheManager配置（业务量不大推荐）" class="headerlink" title="方式二：通过CacheManager配置（业务量不大推荐）"></a>方式二：通过CacheManager配置（业务量不大推荐）</h3><p>spring-data-redis 1.x版本配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">     RedisCacheManager manager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">     manager.setUsePrefix(<span class="keyword">true</span>);</span><br><span class="line">     RedisCachePrefix cachePrefix = <span class="keyword">new</span> RedisPrefix(<span class="string">&quot;prefix&quot;</span>);</span><br><span class="line">     manager.setCachePrefix(cachePrefix);</span><br><span class="line">     <span class="comment">// 整体缓存过期时间</span></span><br><span class="line">     manager.setDefaultExpiration(<span class="number">3600L</span>);</span><br><span class="line">     <span class="comment">// 设置缓存过期时间。key和缓存过期时间，单位秒</span></span><br><span class="line">     Map&lt;String, Long&gt; expiresMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     expiresMap.put(<span class="string">&quot;user&quot;</span>, <span class="number">1000L</span>);</span><br><span class="line">     manager.setExpires(expiresMap);</span><br><span class="line">     <span class="keyword">return</span> manager;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>spring-data-redis 2.x版本配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();  </span><br><span class="line">    <span class="comment">// 生成一个默认配置，通过config对象即可对缓存进行自定义配置</span></span><br><span class="line">    config = config.entryTtl(Duration.ofMinutes(<span class="number">30</span>)) </span><br><span class="line">        <span class="comment">// 设置缓存的默认过期时间，也是使用Duration设置</span></span><br><span class="line">            .disableCachingNullValues();     <span class="comment">// 不缓存空值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个初始化的缓存空间set集合</span></span><br><span class="line">    Set&lt;String&gt; cacheNames =  <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    cacheNames.add(<span class="string">&quot;device&quot;</span>);</span><br><span class="line">    cacheNames.add(<span class="string">&quot;project_type&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个缓存空间应用不同的配置</span></span><br><span class="line">    Map&lt;String, RedisCacheConfiguration&gt; configMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    configMap.put(<span class="string">&quot;device&quot;</span>, config);</span><br><span class="line">    configMap.put(<span class="string">&quot;project_type&quot;</span>, config.entryTtl(Duration.ofHours(<span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 使用自定义的缓存配置初始化一个cacheManager</span></span><br><span class="line">    RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">            .initialCacheNames(cacheNames)</span><br><span class="line">            <span class="comment">// 注意这两句的调用顺序，一定要先调用该方法设置初始化的缓存名，再初始化相关的配置</span></span><br><span class="line">            .withInitialCacheConfigurations(configMap)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用缓存注解使用"><a href="#常用缓存注解使用" class="headerlink" title="常用缓存注解使用"></a>常用缓存注解使用</h2><table><thead><tr><th>注解类型</th><th>作用</th><th>应用</th></tr></thead><tbody><tr><td>@Cacheable</td><td>触发缓存入口</td><td>查询数据缓存</td></tr><tr><td>@CacheEvict</td><td>触发移除缓存</td><td>缓存移除</td></tr><tr><td>@CacahePut</td><td>更新缓存</td><td>用于插入和更新数据操作</td></tr><tr><td>@Caching</td><td>将多种缓存操作分组</td><td>支持更多缓存操作</td></tr><tr><td>@CacheConfig</td><td>允许共享缓存名称</td><td>class级别配置</td></tr></tbody></table><h3 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h3><p>类级别的缓存注解，允许共享缓存名称.该注解是可以将缓存分类，它是类级别的注解方式。我们可以这么使用它。<br>这样的话，UseCacheRedisService的所有缓存注解例如@Cacheable的value值就都为user</p><h2 id="缓存运行流程"><a href="#缓存运行流程" class="headerlink" title="缓存运行流程"></a>缓存运行流程</h2><p>@Cacheable：</p><pre><code>a、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；（CacheManager先获取相应的缓存），如果没有Cache组件，第一次获取缓存会自动创建 b、去Cache中查找缓存的内容，使用一个key，默认就是方法的参数；      key是按照某种策略生成的；默认是使用keyGenerator生成的；默认使用SimpleKeyGenerator生成key      SimpleKeyGenerator生成key的默认策略：       如果没有参数：key=new SimpleKey();如果有一个参数，key=参数的值；如果有多个参数：key= new SimpleKey(params);c、没有查到缓存就调用目标方法；d、将目标方法返回的结果放到缓存中 @Cacheable标注的方法执行之前来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法，并将结果放入缓存。以后再来调用，就可以使用缓存中的数据;</code></pre><h2 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h2><p> a、自动配置类CacheAutoConfiguration给容器中导入组件</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175248061.png" alt="image-20210324175248061"></p><p> c、默认生效的配置类：SimpleCacheConfiguration</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175327261.png" alt="image-20210324175327261"></p><p> d、给容器中注册了一个CacheManager：ConcurrentManager；可以获取和创建ConcurrentMapCache类型的缓存组件，他的作用是将数据保存在ConcurrentMap中。</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175351233.png" alt="image-20210324175351233"></p><h3 id="redis集成Spring原理是什么？"><a href="#redis集成Spring原理是什么？" class="headerlink" title="redis集成Spring原理是什么？"></a>redis集成Spring原理是什么？</h3><p>Spring缓存抽象模块通过CacheManager来创建、管理实际缓存组件，当SpringBoot应用程序引入spring-boot-starter-data-redi依赖后，容器中将注册的是CacheManager实例RedisCacheManager对象，RedisCacheManager来负责创建RedisCache作为缓存管理组件，由RedisCache操作redis服务器实现缓存数据操作。<strong>实际测试发现默认注入的RedisCacheManager操作缓存用的是RedisTemplate&lt;Object, Object&gt;，因此我们需要自定义cacheManager，替换掉默认的序列化器。</strong></p><h3 id="EnableCaching作用是什么？"><a href="#EnableCaching作用是什么？" class="headerlink" title="@EnableCaching作用是什么？"></a>@EnableCaching作用是什么？</h3><p>@EnableCaching注解是spring framework中的注解驱动的缓存管理功能。自spring版本3.1起加入了该注解。<br>当你在配置类(@Configuration)上使用@EnableCaching注解时，会触发一个post processor，这会扫描每一个spring bean，查看是否已经存在注解对应的缓存。如果找到了，就会自动创建一个代理拦截方法调用，使用缓存的bean执行处</p><p>因此我们只要在使用的地方注入即可：</p><p>@Autowired<br>StringRedisTemplate stringRedisTemplate; //操作 k-v 字符串<br>@Autowired<br>RedisTemplate redisTemplate; //k- v 都是对象<br>StringRedisTemplate 提供opsForValue用来操作key-value，如上面的示例，另外还提供了一系列opsForHash()、opsForList()、opsForSet()、opsForZSet()等方法用来操作不同结构类型的数据</p><h1 id="RedisUtils"><a href="#RedisUtils" class="headerlink" title="RedisUtils"></a>RedisUtils</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">// =============================common============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RedisTemplate常用Api"><a href="#RedisTemplate常用Api" class="headerlink" title="RedisTemplate常用Api"></a>RedisTemplate常用Api</h1><h2 id="一、-通用操作工具"><a href="#一、-通用操作工具" class="headerlink" title="一、 通用操作工具"></a>一、 通用操作工具</h2><p>1、常用的分布式锁加强版</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终加强分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String lock = LOCK_PREFIX + key;</span><br><span class="line">        <span class="comment">// 利用lambda表达式</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean) redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> expireAt = System.currentTimeMillis() + LOCK_EXPIRE + <span class="number">1</span>;</span><br><span class="line">                Boolean acquire = redisConnection.setNX(lock.getBytes(), String.valueOf(expireAt).getBytes());</span><br><span class="line">                <span class="keyword">if</span> (acquire) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] value = redisConnection.get(lock.getBytes());</span><br><span class="line">                    <span class="keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">long</span> expireTime = Long.parseLong(<span class="keyword">new</span> String(value));</span><br><span class="line">                        <span class="keyword">if</span> (expireTime &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                            <span class="comment">// 如果锁已经过期</span></span><br><span class="line">                            <span class="keyword">byte</span>[] oldValue = redisConnection.getSet(lock.getBytes(), String.valueOf(System.currentTimeMillis() + LOCK_EXPIRE + <span class="number">1</span>).getBytes());</span><br><span class="line">                            <span class="comment">// 防止死锁</span></span><br><span class="line">                            <span class="keyword">return</span> Long.parseLong(<span class="keyword">new</span> String(oldValue)) &lt; System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2、 删除锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    redisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、指定缓存失效时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定缓存失效时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key,<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、根据key 获取过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.getExpire(key,TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、判断key是否存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断key是否存在</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、删除缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String ... key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key!=<span class="keyword">null</span>&amp;&amp;key.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key.length==<span class="number">1</span>)&#123;</span><br><span class="line">            redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、-String类型相关操作"><a href="#二、-String类型相关操作" class="headerlink" title="二、 String类型相关操作"></a>二、 String类型相关操作</h2><p>1、获取缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key==<span class="keyword">null</span>?<span class="keyword">null</span>:redisTemplate.opsForValue().get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、添加缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、添加缓存并设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加缓存并设置过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key,Object value,<span class="keyword">long</span> time)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、递增操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递增</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、递减操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、-哈希类型相关操作"><a href="#三、-哈希类型相关操作" class="headerlink" title="三、 哈希类型相关操作"></a>三、 哈希类型相关操作</h2><p>1、设置一组Map的键值对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashGet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key,String item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、获取指定Map的所有键值对</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Object,Object&gt; <span class="title">hmget</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、添加一个Map类型值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、 向一张hash表中放入数据,如果不存在将创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key,String item,Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、向一张hash表中放入数据,如果不存在将创建并设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)  注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key,String item,Object value,<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">        <span class="keyword">if</span>(time&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            expire(key, time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、删除hash表中的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除hash表中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span></span>&#123;</span><br><span class="line">    redisTemplate.opsForHash().delete(key,item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、判断hash表中是否有该项的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、递增，如果不存在,就会创建一个 并把新增后的值返回</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item,<span class="keyword">double</span> by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10、递减</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash递减</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item,<span class="keyword">double</span> by)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item,-by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、-SET类型相关操作"><a href="#四、-SET类型相关操作" class="headerlink" title="四、 SET类型相关操作"></a>四、 SET类型相关操作</h2><p>1、根据key获取Set中的所有值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、根据value从一个set中查询,是否存在</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> 根据value从一个set中查询,是否存在</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param key 键</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param value 值</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @return true 存在 false不存在</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="emphasis">*/</span></span></span></span><br><span class="line">public boolean sHasKey(<span class="built_in">String</span> key,<span class="built_in">Object</span> value)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、添加一个SET缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数据放入set缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object...values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、添加一个SET缓存并设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将set数据放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key,<span class="keyword">long</span> time,Object...values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        <span class="keyword">if</span>(time&gt;<span class="number">0</span>) expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、获取SET缓存的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取set缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、移除指定key的缓存</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除值为value的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> long setRemove(String key, Object ...values) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">Long</span> count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、-LIST类型相关操作"><a href="#五、-LIST类型相关操作" class="headerlink" title="五、 LIST类型相关操作"></a>五、 LIST类型相关操作</h2><p>1、获取list缓存的内容</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> 获取list缓存的内容</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param key 键</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param start 开始</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param end 结束  0 到 -1代表所有值</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="emphasis">*/</span></span></span></span><br><span class="line">public <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; lGet(<span class="built_in">String</span> key,long start, long end)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 获取list缓存的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取list缓存的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、通过索引 获取list中的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 索引  index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key,<span class="keyword">long</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、 将list放入缓存</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> 将list放入缓存</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param key 键</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param value 值</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="emphasis">*/</span></span></span></span><br><span class="line">public boolean lSet(<span class="built_in">String</span> key, <span class="built_in">Object</span> value) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、将list放入缓存并设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、将list放入缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将list放入缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、将list放入缓存并设置过期时间</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> 将list放入缓存</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param key 键</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param value 值</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param time 时间(秒)</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="emphasis">*/</span></span></span></span><br><span class="line">public boolean lSet(<span class="built_in">String</span> key, <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; value, long time) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">        <span class="keyword">if</span> (time &gt; <span class="number">0</span>) expire(key, time);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、根据索引修改list中的某条数据</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> 根据索引修改list中的某条数据</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param key 键</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param index 索引</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @param value 值</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> *</span> @return</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="emphasis">*/</span></span></span></span><br><span class="line">public boolean lUpdateIndex(<span class="built_in">String</span> key, long index,<span class="built_in">Object</span> value) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        redisTemplate.opsForList().<span class="keyword">set</span>(key, index, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、移除N个值为value</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除N个值为value</span></span><br><span class="line"><span class="comment"> * @param key 键</span></span><br><span class="line"><span class="comment"> * @param count 移除多少个</span></span><br><span class="line"><span class="comment"> * @param value 值</span></span><br><span class="line"><span class="comment"> * @return 移除的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">long</span> <span class="title">lRemove</span>(<span class="params">String key,<span class="built_in">long</span> count,Object <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Long <span class="keyword">remove</span> = redisTemplate.opsForList().<span class="keyword">remove</span>(key, count, <span class="keyword">value</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">remove</span>;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring的封装RedisTemplate-lt-K-V-gt-对象默认配置"><a href="#Spring的封装RedisTemplate-lt-K-V-gt-对象默认配置" class="headerlink" title="Spring的封装RedisTemplate&lt;K,V&gt;对象默认配置"></a>Spring的封装RedisTemplate&lt;K,V&gt;对象默认配置</h1><h2 id="了解即可"><a href="#了解即可" class="headerlink" title="了解即可"></a>了解即可</h2><p>Spring在 org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration类下配置的两个RedisTemplate的Bean。</p><p>（1) RedisTemplate&lt;Object, Object&gt;</p><p>这个Bean使用JdkSerializationRedisSerializer进行序列化，即key, value需要实现Serializable接口，redis数据格式比较难懂，例如</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175423920.png" alt="image-20210324175423920"></p><p>（2) StringRedisTemplate，即RedisTemplate&lt;String, String&gt;</p><p>key和value都是String。当需要存储实体类时，需要先转为String，再存入Redis。一般转为Json格式的字符串，所以使用StringRedisTemplate，需要手动将实体类转为Json格式。如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ValueOperations&lt;String, String&gt; valueTemplate = stringTemplate.opsForValue();</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">valueTemplate.set(<span class="string">&quot;StringKey1&quot;</span>, <span class="string">&quot;hello spring boot redis, String Redis&quot;</span>);</span><br><span class="line">String value = valueTemplate.get(<span class="string">&quot;StringKey1&quot;</span>);</span><br><span class="line">System.out.println(value);</span><br><span class="line"></span><br><span class="line">valueTemplate.set(<span class="string">&quot;StringKey2&quot;</span>, gson.toJson(<span class="keyword">new</span> Person(<span class="string">&quot;theName&quot;</span>, <span class="number">11</span>)));</span><br><span class="line">Person person = gson.fromJson(valueTemplate.get(<span class="string">&quot;StringKey2&quot;</span>), Person.class);</span><br><span class="line">System.out.println(person);</span><br></pre></td></tr></table></figure><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/image-20210324175443189.png" alt="image-20210324175443189"></p><h2 id="配置一个RedisTemplate-lt-String-Object-gt-的Bean"><a href="#配置一个RedisTemplate-lt-String-Object-gt-的Bean" class="headerlink" title="配置一个RedisTemplate&lt;String,Object&gt;的Bean"></a>配置一个RedisTemplate&lt;String,Object&gt;的Bean</h2><p>Spring配置的两个RedisTemplate都不太方便使用，所以可以配置一个RedisTemplate&lt;String,Object&gt; 的Bean，key使用String即可(包括Redis Hash 的key)，value存取Redis时默认使用Json格式转换。如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;template&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">template</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 创建RedisTemplate&lt;String, Object&gt;对象</span></span><br><span class="line">       RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">       <span class="comment">// 配置连接工厂</span></span><br><span class="line">       template.setConnectionFactory(factory);</span><br><span class="line">       <span class="comment">// 定义Jackson2JsonRedisSerializer序列化对象</span></span><br><span class="line">       Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSeial = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">       ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">       om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">       <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会报异常</span></span><br><span class="line">       om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">       jacksonSeial.setObjectMapper(om);</span><br><span class="line">       StringRedisSerializer stringSerial = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">       <span class="comment">// redis key 序列化方式使用stringSerial</span></span><br><span class="line">       template.setKeySerializer(stringSerial);</span><br><span class="line">       <span class="comment">// redis value 序列化方式使用jackson</span></span><br><span class="line">       template.setValueSerializer(jacksonSeial);</span><br><span class="line">       <span class="comment">// redis hash key 序列化方式使用stringSerial</span></span><br><span class="line">       template.setHashKeySerializer(stringSerial);</span><br><span class="line">       <span class="comment">// redis hash value 序列化方式使用jackson</span></span><br><span class="line">       template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">       template.afterPropertiesSet();</span><br><span class="line">       <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; template;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test002</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueOperations&lt;String, Object&gt; redisString = template.opsForValue();   </span><br><span class="line">    <span class="comment">// SET key value: 设置指定 key 的值   </span></span><br><span class="line">    redisString.set(<span class="string">&quot;strKey1&quot;</span>, <span class="string">&quot;hello spring boot redis&quot;</span>);   </span><br><span class="line">    <span class="comment">// GET key: 获取指定 key 的值   </span></span><br><span class="line">    String value = (String) redisString.get(<span class="string">&quot;strKey1&quot;</span>);   </span><br><span class="line">    System.out.println(value);</span><br><span class="line">    redisString.set(<span class="string">&quot;strKey2&quot;</span>, <span class="keyword">new</span> User(<span class="string">&quot;ID10086&quot;</span>, <span class="string">&quot;theName&quot;</span>, <span class="number">11</span>));</span><br><span class="line">    User user = (User) redisString.get(<span class="string">&quot;strKey2&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Redis缓存数据库数据"><a href="#使用Redis缓存数据库数据" class="headerlink" title="使用Redis缓存数据库数据"></a>使用Redis缓存数据库数据</h2><p>Redis有很多使用场景，一个demo就是缓存数据库的数据。Redis作为一个内存数据库，存取数据的速度比传统的数据库快得多。使用Redis缓存数据库数据，可以减轻系统对数据库的访问压力，及加快查询效率等好处。下面讲解如何使用 SpringBoot + Redis来缓存数据库数据(这里数据库使用MySql)。</p><h3 id="配置Redis作为Spring的缓存管理"><a href="#配置Redis作为Spring的缓存管理" class="headerlink" title="配置Redis作为Spring的缓存管理"></a>配置Redis作为Spring的缓存管理</h3><p>Spring支持多种缓存技术：RedisCacheManager、EhCacheCacheManager、GuavaCacheManager等，使用之前需要配置一个CacheManager的Bean。配置好之后使用三个注解来缓存数据：@Cacheable，@CachePut 和 @CacheEvict。这三个注解可以加Service层或Dao层的类名上或方法上(建议加在Service层的方法上)，加上类上表示所有方法支持该注解的缓存；三注解需要指定Key，以返回值作为value操作缓存服务。所以，如果加在Dao层，当新增1行数据时，返回数字1，会将1缓存到Redis，而不是缓存新增的数据。</p><p>RedisCacheManager的配置如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;SpringBoot配置redis作为默认缓存工具&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;SpringBoot 2.0 以上版本的配置&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate&lt;String, Object&gt; template)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfiguration =</span><br><span class="line">                RedisCacheConfiguration</span><br><span class="line">                        .defaultCacheConfig()</span><br><span class="line">                        <span class="comment">// 设置key为String</span></span><br><span class="line">                        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getStringSerializer()))</span><br><span class="line">                        <span class="comment">// 设置value 为自动转Json的Object</span></span><br><span class="line">                        .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(template.getValueSerializer()))</span><br><span class="line">                        <span class="comment">// 不缓存null</span></span><br><span class="line">                        .disableCachingNullValues()</span><br><span class="line">                        <span class="comment">// 缓存数据保存1小时</span></span><br><span class="line">                        .entryTtl(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        RedisCacheManager redisCacheManager =</span><br><span class="line">                RedisCacheManagerBuilder</span><br><span class="line">                        <span class="comment">// Redis 连接工厂</span></span><br><span class="line">                        .fromConnectionFactory(template.getConnectionFactory())</span><br><span class="line">                        <span class="comment">// 缓存配置</span></span><br><span class="line">                        .cacheDefaults(defaultCacheConfiguration)</span><br><span class="line">                        <span class="comment">// 配置同步修改或删除 put/evict</span></span><br><span class="line">                        .transactionAware()</span><br><span class="line">                        .build();</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Cacheabl、-CachePut、-CacheEvict的使用"><a href="#Cacheabl、-CachePut、-CacheEvict的使用" class="headerlink" title="@Cacheabl、@CachePut、@CacheEvict的使用"></a>@Cacheabl、@CachePut、@CacheEvict的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定默认缓存区</span></span><br><span class="line"><span class="comment"> * 缓存区：key的前缀，与指定的key构成redis的key，如 user::10001</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao dao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Cacheable</span> 缓存有数据时，从缓存获取；没有数据时，执行方法，并将返回值保存到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Cacheable</span> 一般在查询中使用</span></span><br><span class="line"><span class="comment">     * 1) cacheNames 指定缓存区，没有配置使用<span class="doctag">@CacheConfig</span>指定的缓存区</span></span><br><span class="line"><span class="comment">     * 2) key 指定缓存区的key</span></span><br><span class="line"><span class="comment">     * 3) 注解的值使用SpEL表达式</span></span><br><span class="line"><span class="comment">     * eq ==</span></span><br><span class="line"><span class="comment">     * lt &lt;</span></span><br><span class="line"><span class="comment">     * le &lt;=</span></span><br><span class="line"><span class="comment">     * gt &gt;</span></span><br><span class="line"><span class="comment">     * ge &gt;=</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(cacheNames = &quot;user&quot;, key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(key=&quot;&#x27;list&#x27;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * condition 满足条件缓存数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;, condition = &quot;#number ge 20&quot;)</span> <span class="comment">// &gt;= 20</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserByIdWithCondition</span><span class="params">(String id, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unless 满足条件时否决缓存数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Cacheable(key = &quot;#id&quot;, unless = &quot;#number lt 20&quot;)</span> <span class="comment">// &lt; 20</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserByIdWithUnless</span><span class="params">(String id, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.selectUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**　　　* <span class="doctag">@CachePut</span> 一定会执行方法，并将返回值保存到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@CachePut</span> 一般在新增和修改中使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        dao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;, condition = &quot;#user.age ge 20&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">insertUserWithCondition</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        dao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CachePut(key = &quot;#user.id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        dao.updateUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key删除缓存区中的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        dao.deleteUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * allEntries = true ：删除整个缓存区的所有值，此时指定的key无效</span></span><br><span class="line"><span class="comment">     * beforeInvocation = true ：默认false，表示调用方法之后删除缓存数据；true时，在调用之前删除缓存数据(如方法出现异常)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CacheEvict(key = &quot;#id&quot;, allEntries = true)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserByIdAndCleanCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        dao.deleteUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis共享-Session"><a href="#Redis共享-Session" class="headerlink" title="Redis共享 Session"></a>Redis共享 Session</h1><p>分布式系统中，Session 共享有很多的解决方案，其中托管到缓存中应该是最常用的方案之一</p><p><strong>Spring Session 官方说明</strong></p><p>Spring Session provides an API and implementations for managing a user’s session information.</p><p>Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案。Spring Session 提供了集群 Session（Clustered Sessions）功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a><strong>如何使用</strong></h3><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">session:</span></span><br><span class="line">        <span class="attr">store-type:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>2、Session 配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableRedisHttpSession(maxInactiveIntervalInSeconds &#x3D; 86400*30)</span><br><span class="line">public class SessionConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxInactiveIntervalInSeconds: 设置 Session 失效时间，使用 Redis Session 之后，原 Spring Boot 的 server.session.timeout 属性不再生效。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Redis, Spring Boot, 使用" scheme="https://wllshdx.github.io/tags/Redis-Spring-Boot-%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Apache全家桶使用</title>
    <link href="https://wllshdx.github.io/2021/03/20/ApacheTools/"/>
    <id>https://wllshdx.github.io/2021/03/20/ApacheTools/</id>
    <published>2021-03-20T08:55:19.000Z</published>
    <updated>2021-03-25T03:02:24.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Apache全家桶不完全使用指南"><a href="#Apache全家桶不完全使用指南" class="headerlink" title="Apache全家桶不完全使用指南"></a>Apache全家桶不完全使用指南</h1><p>平常我们在日常的开发中会一些通用的功能封装成一些工具类，以便之后复用。但是有些常用功能，业界已经存在，我们无需造轮子，只需直接使用或借用它们的 Api ，构建我们的自己项目中工具类。这篇首先介绍平常用到的 Apache 工具全家桶。</p><ul><li>commons-lang3</li><li>commons-io</li><li>commons-collections</li><li>commons-codec[加密-解密]</li></ul><p>&lt;<span id="more"></span></p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/2020042810093443.png" alt="image-20200524214713424"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="commons-beanutils"><a href="#commons-beanutils" class="headerlink" title="commons-beanutils"></a>commons-beanutils</h2><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-beanutils<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>注意：</code>实际开发应选择 <code>Spring BeanUtils</code>，一方面不需要额外引入依赖包，另一方面性能会比Apache BeanUtils 性能好一些（同理的还有 <code>Spring StringUtils</code>）。注意，是浅拷贝</p><p><img src="https://wll-image.oss-cn-beijing.aliyuncs.com/2020042810093443.png" alt="在这里插入图片描述"></p><p>【常用API】</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把orig对象copy到dest对象中.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyProperties</span> <span class="params">(Object dest, Object orig)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 把Bean的属性值放入到一个Map里面</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">describe</span><span class="params">(Object bean)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 把map里面的值放入bean中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populate</span> <span class="params">(Object bean, Map map)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置Bean对象中名称为name的属性值赋值为value.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperty</span><span class="params">(Object bean,String name, Object value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 取得bean对象中名为name的属性的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(Object bean, String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当需要将String数据转换成引用数据类型（自定义数据类型时），需要使用此方法实现转换。    </span></span></span><br><span class="line"><span class="function">ConvertUtils.<span class="title">register</span><span class="params">(Converter converter , ..)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>【常见使用场景】<br>    同类之间不同对象要求进行数据复制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line">user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 把user1复制给user2</span></span><br><span class="line">BeanUtils. copyProperties(user2,user1);</span><br></pre></td></tr></table></figure><p>不同类不同对象之间的数据复制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user1 = <span class="keyword">new</span> User();</span><br><span class="line">user1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 把user1复制给user2</span></span><br><span class="line">BeanUtils. copyProperties(user2,user1);</span><br></pre></td></tr></table></figure><p>对象数据和Map之间互相转化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 将对象转换为Map</span></span><br><span class="line">Map userMap = BeanUtils.describe(user);</span><br><span class="line"></span><br><span class="line">Map userMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">// 将Map转换为对象</span></span><br><span class="line">BeanUtils.populate(user,userMap); </span><br></pre></td></tr></table></figure><p>【日期类型的拷贝】</p><p>BeanUtils.copyProperties支持Date类型：<br>【转】<a href="https://blog.csdn.net/adam_wzs/article/details/54092732">BeanUtils.copyProperties支持Date类型</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.ConvertUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展BeanUtils.copyProperties支持data类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtilsEx</span> <span class="keyword">extends</span> <span class="title">BeanUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(BeanUtilsEx.class);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">ConvertUtils.register(<span class="keyword">new</span> DateConvert(), java.util.Date.class);</span><br><span class="line">ConvertUtils.register(<span class="keyword">new</span> DateConvert(), String.class);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyProperties</span><span class="params">(Object target, Object source)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 支持对日期copy</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">org.apache.commons.beanutils.BeanUtils.copyProperties(target, source);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;扩展BeanUtils.copyProperties支持data类型:&quot;</span> + e.getMessage());</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.beanutils.Converter;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩展BeanUtils.copyProperties支持data类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConvert</span> <span class="keyword">implements</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convert</span><span class="params">(Class class1, Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Date) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">Long longValue = (Long) value;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Date(longValue.longValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String dateStr = (String) value;</span><br><span class="line">Date endTime = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String regexp1 = <span class="string">&quot;([0-9]&#123;4&#125;)-([0-1][0-9])-([0-3][0-9])T([0-2][0-9]):([0-6][0-9]):([0-6][0-9])&quot;</span>;</span><br><span class="line">String regexp2 = <span class="string">&quot;([0-9]&#123;4&#125;)-([0-1][0-9])-([0-3][0-9])(/t)([0-2][0-9]):([0-6][0-9]):([0-6][0-9])&quot;</span>;</span><br><span class="line">String regexp3 = <span class="string">&quot;([0-9]&#123;4&#125;)-([0-1][0-9])-([0-3][0-9])&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (dateStr.matches(regexp1)) &#123;</span><br><span class="line">dateStr = dateStr.split(<span class="string">&quot;T&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + dateStr.split(<span class="string">&quot;T&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">endTime = sdf.parse(dateStr);</span><br><span class="line"><span class="keyword">return</span> endTime;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dateStr.matches(regexp2)) &#123;</span><br><span class="line">DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">endTime = sdf.parse(dateStr);</span><br><span class="line"><span class="keyword">return</span> endTime;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dateStr.matches(regexp3)) &#123;</span><br><span class="line">DateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">endTime = sdf.parse(dateStr);</span><br><span class="line"><span class="keyword">return</span> endTime;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dateStr;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="commons-lang3"><a href="#commons-lang3" class="headerlink" title="commons-lang3"></a>commons-lang3</h2><p>这个包主要扩展 java.lang 下核心类的方法，提供工具类方便我们平常 java.lang 下面的类，如 String , Date。以下介绍其常用的方法。</p><h3 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h3><p>字符串相关操作，扩展 String 相关方法，可以使我们方便处理字符串，满足我们的日常使用。</p><p>StringUtils.isBlank || StringUtils.isEmpty 判断字符串是否为空</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两者都可以用于判断字符串是为空 isBlank 主要用于判断空白字符串 空字符(&quot;&quot;) 以及Null 而 isEmpty 主要用于判断空字符(&quot;&quot;)以及Null</span></span><br><span class="line">StringUtils.isBlank(<span class="string">&quot; &quot;</span>)       = <span class="keyword">true</span> </span><br><span class="line">StringUtils.isEmpty(<span class="string">&quot; &quot;</span>)       = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>StringUtils.countMatches 用于计数匹配上字符的数量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringUtils.countMatches(<span class="string">&quot;abba&quot;</span>, <span class="string">&quot;a&quot;</span>)   = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>StringUtils.defaultIfEmpty 用于当字符串为空时，设置默认字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringUtils.defaultIfEmpty(<span class="string">&quot;&quot;</span>, <span class="string">&quot;NULL&quot;</span>)    = <span class="string">&quot;NULL&quot;</span></span><br></pre></td></tr></table></figure><p>StringUtils.equalsIgnoreCase StringUtils.equals 用于判断字符串是否相等，前者忽略大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringUtils.equals(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.equalsIgnoreCase(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;ABC&quot;</span>) = <span class="keyword">true</span></span><br><span class="line"><span class="comment">// 推荐使用该方法比较字符串，如果使用 a.equals(b),必须确保 a!=null</span></span><br><span class="line">StringUtils.equals(<span class="keyword">null</span>, <span class="string">&quot;abc&quot;</span>)  = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>StringUtils.join 字符串连接函数，可以将字符串数组或集合，按照指定字符连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 碰到这种需要固定分隔符拼接的情况，可以使用该函数，以免我们写一大串函数循环拼接</span></span><br><span class="line">StringUtils.join([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>], <span class="string">&#x27;;&#x27;</span>)  = <span class="string">&quot;a;b;c&quot;</span></span><br></pre></td></tr></table></figure><p>StringUtils.split 说完拼接，必定会有按照固定分隔符拆分的情况</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split 分隔后会忽略为空的字符 如果不能忽略的话 使用 splitPreserveAllTokens</span></span><br><span class="line">StringUtils.split(<span class="string">&quot;ab::ef&quot;</span>, <span class="string">&quot;:&quot;</span>) = [<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;ef&quot;</span>]</span><br><span class="line">StringUtils.splitPreserveAllTokens(<span class="string">&quot;ab::ef&quot;</span>,<span class="string">&quot;:&quot;</span>)=[<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;ef&quot;</span>]</span><br></pre></td></tr></table></figure><p>判断包含关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断某个字符串是否包含另外一个字符串，StringUtils中提供了过个方法，其实通过方法名就能猜到每个方法的使用方式</span></span><br><span class="line">StringUtils.contains(a,b);</span><br><span class="line">StringUtils.containsAny(a,b);</span><br><span class="line">StringUtils.containsNone(a,b);</span><br><span class="line">StringUtils.containsOnly(a,b);</span><br></pre></td></tr></table></figure><p>String中有方法startWith() 和 endWith() 若一个字符串为空的时候调用方法就会报空指针异常，但是使用StringUtils就可以避免</p><p>其它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isBlank(str);<span class="comment">// &quot; &quot; 为 true</span></span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isEmpty(str);<span class="comment">// &quot; &quot; 为 false</span></span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isNotBlank(str);</span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isNotEmpty(str);</span><br><span class="line"></span><br><span class="line">String[] StringUtils.split(str,<span class="keyword">char</span>/String,max);<span class="comment">//切割字符串，使用给定字符 ;  max 主要是用来处理空内容的</span></span><br><span class="line"></span><br><span class="line">String StringUtils.capitalize(str);<span class="comment">//首字母大写</span></span><br><span class="line">String StringUtils.uncapitalize(str);<span class="comment">//首字母小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isNumeric(str);</span><br><span class="line"><span class="keyword">boolean</span> StringUtils.isNumericSpace(str);<span class="comment">// &quot;&quot; 为true &quot;12 3&quot; 为 true</span></span><br><span class="line"></span><br><span class="line">String StringUtils.join(array/Iterable,chat/String);<span class="comment">// 类似于 js 的 join ,使用给定字符拼接数组或集合中的元素</span></span><br><span class="line"></span><br><span class="line">String StringUtils.leftPad(str,size,padChar);<span class="comment">//给左边拼接固定长度的字符</span></span><br><span class="line">String StringUtils.rightPad(str,size,padChar);<span class="comment">//右边拼接固定长度的字符</span></span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line"><span class="comment">//若a为字符串，但是可能为空，那么就可能出现空指针</span></span><br><span class="line"><span class="keyword">boolean</span> rs = a.endWith(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若使用工具类StringUtils，那么即使a为空也不会出现空指针</span></span><br><span class="line"><span class="keyword">boolean</span> rs = StringUtils.endWith(a,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">StringUtils.replace() 将字符串中某些内容替换</span><br><span class="line"></span><br><span class="line">StringUtils.indexOf() 判断某个字符在字符串中的第一次出现的下标位置</span><br><span class="line"></span><br><span class="line">StringUtils.lastIndexOf() 判断某个字符在字符串中最后一次出现的位置</span><br></pre></td></tr></table></figure><h3 id="ArrayUtils"><a href="#ArrayUtils" class="headerlink" title="ArrayUtils"></a>ArrayUtils</h3><p>由于平常工作中习惯用集合代替数组对象，所以没有经常使用该类。</p><p>ArrayUtils.isEmpty 判断数组是否为空</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">ArrayUtils.isEmpty(a)=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="DateFormatUtils"><a href="#DateFormatUtils" class="headerlink" title="DateFormatUtils"></a>DateFormatUtils</h3><p>将时间按照指定格式输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateFormatUtils.format(new Date(), &quot;yyyy-MM-dd HH:mm:ss&quot;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DurationFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ToStringBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ToStringStyle;</span><br><span class="line"></span><br><span class="line">DateFormatUtils.format(Date/Calendar/<span class="keyword">long</span>,pattern);</span><br><span class="line">DateFormatUtils.ISO_DATE_FORMAT.format(Date/Calendar/<span class="keyword">long</span>);<span class="comment">// yyyy-MM-dd</span></span><br><span class="line">DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(Date/Calendar/<span class="keyword">long</span>);<span class="comment">// HH:mm:ss</span></span><br><span class="line"></span><br><span class="line">DurationFormatUtils.formatDuration(<span class="keyword">long</span>,format);<span class="comment">//格式化毫秒值为指定格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于实体类 param,po,dto,vo</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ToStringBuilder.reflectionToString(<span class="keyword">this</span>,ToStringStyle.SHORT_PREFIX_STYLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DateUtils"><a href="#DateUtils" class="headerlink" title="DateUtils"></a>DateUtils</h3><p>该类可以将时间按照格式解析成 Date 类型，还可以用于时间计算</p><p>DateUtils.parseDate 按照格式转化成 Date 类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateUtils.parseDate(<span class="string">&quot;2018-05-27 16:32:51&quot;</span>,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>) </span><br><span class="line"><span class="comment">// 将字符串转化成 Date 对象</span></span><br></pre></td></tr></table></figure><p>DateUtils.addDays addHours addMinutes 用于在指定 Date 加上相应时间，如想获取当前时间20天后的日期，就就可以使用 DateUtils.addDays。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">&quot;2018-05-27 16:32:51&quot;</span>,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">DateUtils.addDays(date,<span class="number">1</span>);<span class="comment">// date 为：2018-05-28 16:32:51</span></span><br><span class="line">DateUtils.addHours(date,<span class="number">1</span>)<span class="comment">// date 为：2018-05-28 17:32:51</span></span><br><span class="line">DateUtils.addMonths();  <span class="comment">//添加月</span></span><br><span class="line">DateUtils.addWeeks();   <span class="comment">//添加周</span></span><br><span class="line">DateUtils.addDays();    <span class="comment">//添加天</span></span><br><span class="line">DateUtils.addHours();   <span class="comment">//添加小时</span></span><br><span class="line">DateUtils.addMinutes(); <span class="comment">//添加分钟</span></span><br><span class="line">DateUtils.addSeconds()  <span class="comment">//添加秒</span></span><br></pre></td></tr></table></figure><p>DateUtils.truncate 按照指定时间类型截断时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">&quot;2018-05-27 16:32:51&quot;</span>,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">DateUtils.truncate(date, Calendar.DATE);<span class="comment">// 2018-05-27 00:00:00</span></span><br><span class="line">DateUtils.truncate(date, Calendar.HOUR);<span class="comment">// 2018-05-27 16:00:00</span></span><br><span class="line"><span class="comment">// 如果按照 Date 截断时间，那么 Date 后面小时，分钟等全部置为0，相当于舍弃了 Date 之后的时间。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class="line"></span><br><span class="line">Date DateUtils.parseDate(str,parsePatterns);</span><br><span class="line"><span class="keyword">boolean</span> DateUtils.isSameDay(Date,Date);<span class="comment">//判断两个日期是否是同一天</span></span><br><span class="line"></span><br><span class="line">Date DateUtils.truncate(Date,field);<span class="comment">//日期截取，只取指定日期字段的值</span></span><br><span class="line">Date DateUtils.round(Date,field);<span class="comment">// 日期四舍五入，和 truncate 的区别是 如果用 YEAR 当前时间是 2019-08-18 truncate 的值还是 2019 ，但 round 会得到 2020 </span></span><br><span class="line"></span><br><span class="line">Date DateUtils.addDays(Date,amount);<span class="comment">//增加一天,这个不会修改原来的日期值</span></span><br><span class="line">还有 addYears,addMonths,addWeeks,addHours,addMinutes,addSeconds,addMilliseconds</span><br><span class="line"></span><br><span class="line">Date DateUtils.setDays(Date,amount);<span class="comment">//设置为本月的第几天</span></span><br><span class="line">还有 setYears,setMonths,setHours,setMinutes,setSeconds,setMilliseconds</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算已过去的天数，从哪儿开始算呢，根据第2个参数fragment来确定，</span></span><br><span class="line"><span class="comment">如现在是2014-10-23 13:27:00，那么</span></span><br><span class="line"><span class="comment">DateUtils.getFragmentInDays(new Date(), Calendar.MONTH)返回23，表示从当月起已经过去23天了，</span></span><br><span class="line"><span class="comment">DateUtils.getFragmentInDays(new Date(), Calendar.YEAR)返回296，表示从当年起已经过去296天了，</span></span><br><span class="line"><span class="comment">DateUtils.getFragmentInHours(new Date(), Calendar.DATE)返回13，表示从今天起已经过去13个小时了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">long</span> DateUtils.getFragmentInDays(Date,fragment);<span class="comment">//计算已经过去的天数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DateUtils工具类还提供了将日期Date转换成日历的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = DateUtils.toCalendar(date);</span><br></pre></td></tr></table></figure><h3 id="NumberUtils"><a href="#NumberUtils" class="headerlink" title="NumberUtils"></a>NumberUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.math.NumberUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> NumberUtils.toInt(String);</span><br><span class="line">还有 toLong,toDouble,toFloat,toShort 等</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> NumberUtils.isDigits(String);<span class="comment">//判断是否全由数字组成 &quot;&quot; 为 false</span></span><br><span class="line"><span class="keyword">boolean</span> NumberUtils.isNumber(String);<span class="comment">// 支持 0x 类的表达形式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="增强反射处理"><a href="#增强反射处理" class="headerlink" title="增强反射处理"></a>增强反射处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ClassUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.reflect.MethodUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; ClassUtils.getClass(className);</span><br><span class="line"><span class="keyword">boolean</span> ClassUtils.isInnerClass(Class&lt;?&gt;);<span class="comment">//是否是内部类</span></span><br><span class="line"><span class="keyword">boolean</span> ClassUtils.isPrimitiveOrWrapper(Class&lt;?&gt;);<span class="comment">//判断是否是原始类型或原始类型的包装类</span></span><br><span class="line"></span><br><span class="line">List&lt;Method&gt; MethodUtils.getMethodsListWithAnnotation( Class&lt;?&gt;, Class&lt;? extends Annotation&gt;);</span><br><span class="line">Method ReflectionUtils.findMethod(Class&lt;?&gt; clazz,methodName, Class&lt;?&gt;...);</span><br><span class="line">PropertyDescriptor[] ReflectUtils.getBeanGetters(Class type);</span><br><span class="line"></span><br><span class="line">Object MethodUtils.invokeMethod(object,methodName,args[],values[]);<span class="comment">//调用方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.RandomStringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> RandomUtils.nextInt(start,end);</span><br><span class="line"><span class="keyword">long</span> RandomUtils.nextLong(start,end);</span><br><span class="line"></span><br><span class="line">String RandomStringUtils.randomNumeric(count);</span><br><span class="line">String RandomStringUtils.randomAlphabetic(count);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="commons-io"><a href="#commons-io" class="headerlink" title="commons-io"></a>commons-io</h2><blockquote><p>Commons IO is a library of utilities to assist with developing IO functionality.</p></blockquote><p>主要包含一些 IO 相关的工具类,可以简化处理文件相关操作</p><h3 id="FileUtils"><a href="#FileUtils" class="headerlink" title="FileUtils"></a>FileUtils</h3><p>文件操作相关工具类</p><p>FileUtils.copyDirectory || FileUtils.copyFile 拷贝文件夹或文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 拷贝文件</span><br><span class="line">File fileA &#x3D; new File(&quot;E:\\test\\test.txt&quot;);</span><br><span class="line">File fileB &#x3D; new File(&quot;E:\\test1\\test.txt&quot;);</span><br><span class="line">FileUtils.copyFile(fileA,fileB);</span><br></pre></td></tr></table></figure><p>FileUtils.listFiles 获取指定文件夹上所有文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 按照指定文件后缀如java,txt等去查找指定文件夹的文件</span><br><span class="line">File directory &#x3D; new File(&quot;E:\\test&quot;);</span><br><span class="line">FileUtils.listFiles(directory, new String[]&#123;&quot;txt&quot;&#125;, false);</span><br></pre></td></tr></table></figure><p>FileUtils.readLines 读取文件所有行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取指定文件所有行 不需要使用 while 循环读取流了</span></span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(fileA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件返回读取的内容字符串，另一个重载的方法可以设置编码</span></span><br><span class="line">        String context = FileUtils.readFileToString(file);</span><br><span class="line">        String context = FileUtils.readFileToString(file,encoding);</span><br><span class="line">       </span><br><span class="line"><span class="comment">//读取文件返回字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = FileUtils.readFileToByteArray(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件返回流</span></span><br><span class="line">        FileInputStream fileInputStream = FileUtils.openInputStream(file);</span><br><span class="line">        FileOutputStream fileOutputStream = FileUtils.openOutputStream(file);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//既然有读取文件内容的方法那么必然也有写的方法</span></span><br><span class="line">       FileUtils.writeStringToFile(file,data);</span><br><span class="line">       FileUtils.writeStringToFile(file,data,encoding);</span><br></pre></td></tr></table></figure><p>FileUtils.writeLines 有读就存在写，该方法可以一行行写入文本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以一行行写入文本</span></span><br><span class="line">List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">.....</span><br><span class="line">FileUtils.writeLines(lines)</span><br></pre></td></tr></table></figure><p>其它：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FilenameUtils;</span><br><span class="line"></span><br><span class="line">String IOUtils.toString(InputStream,encoding);<span class="comment">//文本文件流读出字符串</span></span><br><span class="line">List&lt;String&gt; IOUtils.readLines(InputStream,encoding);<span class="comment">//文本文件读出 List&lt;String&gt;</span></span><br><span class="line"><span class="keyword">int</span> IOUtils.copy(InputStream, OutputStream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FileUtils.writeStringToFile(File, String, Charset);</span><br><span class="line"><span class="keyword">void</span> FileUtils.deleteDirectory(File);</span><br><span class="line"></span><br><span class="line">String FilenameUtils.getBaseName(filename);<span class="comment">//获取文件名</span></span><br><span class="line">String FilenameUtils.getExtension(filename);<span class="comment">//获取扩展名</span></span><br><span class="line">String FilenameUtils.separatorsToUnix(String path);<span class="comment">//转成 linux 路径分隔符</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>删除文件或目录<br>FileUtils提供了删除文件或目录的方法，比如要清空某个文件目录下的所有内容，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空目录objective下的所有内容，但是不删除objective目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\objective&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileUtils.cleanDirectory(<span class="keyword">new</span> File(<span class="string">&quot;G:\\objective&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与cleanDirectory()方法不同的还有一个删除目录的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除目录objective以及子目录子文件,即G盘下没有了objective目录</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\objective&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileUtils.deleteDirectory(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IOUtils"><a href="#IOUtils" class="headerlink" title="IOUtils"></a>IOUtils</h3><p>Io 操作相关，FileUtils 很多方法底层调用的是该类的方法</p><p>IOUtils.toString 将输入流转化为指定编码格式的字符串，该方法非常使用与 http 异步回调的场景</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 http 异步回调的报文</span><br><span class="line">String resMsg &#x3D; IOUtils.toString(request.getInputStream());</span><br></pre></td></tr></table></figure><p>IOUtils.toByteArray 将输入流转化为 byte 数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 http 异步回调的报文</span><br><span class="line">byte[] b &#x3D; IOUtils.toByteArray(request.getInputStream());</span><br></pre></td></tr></table></figure><p>IOUtils.closeQuietly 关闭流，不需要在关闭前写判断和try-catch语句，commons-io 2.6 该方法已被 <strong>Deprecated</strong> ， 官方推荐使用 JDK7 try-with-resources 关闭。<strong>注：</strong> <em>该方法如果在输入流等 close 时，若产生 Exception ，异常将会被该方法吞掉。</em></p><p>IOUtils是对流的操作，我们常常操作文件的时候就使用io流，所以上面FileUtils提到的文件复制也可以使用IOUtils实现，只是IOUtils是对文件流进行操作。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;IOUtils有多个重载的copy()方法，返回复制的字节数，示例如下：</span><br><span class="line">File srcFile &#x3D; new File(&quot;G:\\original\\src\\test - 副本.txt&quot;);</span><br><span class="line">File destFile &#x3D; new File(&quot;G:\\objective\\desc\\copy.txt&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">    FileInputStream fileInputStream &#x3D; FileUtils.openInputStream(srcFile);</span><br><span class="line">    FileOutputStream fileOutputStream &#x3D; FileUtils.openOutputStream(destFile);</span><br><span class="line">    int copy &#x3D; IOUtils.copy(fileInputStream, fileOutputStream);</span><br><span class="line">    System.out.println(copy);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;copy方法</span><br><span class="line">copy(InputStream input, OutputStream output)</span><br><span class="line">copy(InputStream input, Writer output)</span><br><span class="line">copy(InputStream input, Writer output, String encoding)</span><br><span class="line">copy(Reader input, Writer output)</span><br><span class="line">copy(Reader input, OutputStream output)</span><br><span class="line">copy(Reader input, OutputStream output, String encoding)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IOUtils还提供了两个重载的方法，用于判断两个流的内容是否相同，比如读取两个文件返回了流，那么想要判断两个文件的内容是否相同，那么可以使用IOUtils提供的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileInputStream fileInputStream1 &#x3D; FileUtils.openInputStream(destFile);</span><br><span class="line">FileInputStream fileInputStream2 &#x3D; FileUtils.openInputStream(destFile1);</span><br><span class="line">boolean b &#x3D; IOUtils.contentEquals(fileInputStream1, fileInputStream);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重载的方法</span><br><span class="line">contentEquals(Reader input1, Reader input2)</span><br></pre></td></tr></table></figure><h3 id="FilenameUtils"><a href="#FilenameUtils" class="headerlink" title="FilenameUtils"></a>FilenameUtils</h3><p>在处理一些文件路径问题时，如果我们代码开发在 Windows 平台，部署却是在 Linux 平台，这个时候我们必须考虑平台分隔符问题。FilenameUtils 解决了平台问题，不用担心平台系统问题，导致的bug。</p><p>FilenameUtils.getBaseName 获取文件名字，去除前缀加扩展名 FilenameUtils.getExtension 获取文件扩展名，去除路径以及文件名 FilenameUtils.getName 获取文件全名，去除路径</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FilenameUtils.getBaseName(&quot;E:\\test\\test.txt&quot;)&#x2F;&#x2F;test</span><br><span class="line">FilenameUtils.getExtension(&quot;E:\\test\\test.txt&quot;)&#x2F;&#x2F;txt</span><br><span class="line">FilenameUtils.getName(&quot;E:\\test\\test.txt&quot;)&#x2F;&#x2F; test.txt</span><br></pre></td></tr></table></figure><p>FilenameUtils.concat 文件路径拼接，不用担心文件的分隔符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FilenameUtils.concat(&quot;E:\\test&quot;, &quot;test.txt&quot;);&#x2F;&#x2F;E:\test\test.txt</span><br></pre></td></tr></table></figure><h2 id="commons-collections"><a href="#commons-collections" class="headerlink" title="commons-collections"></a>commons-collections</h2><blockquote><p>The Java Collections Framework was a major addition in JDK 1.2. It added many powerful data structures that accelerate development of most significant Java applications. Since that time it has become the recognised standard for collection handling in Java</p></blockquote><p>commons-collections 主要增强 java Collections 功能</p><h3 id="CollectionUtils"><a href="#CollectionUtils" class="headerlink" title="CollectionUtils"></a>CollectionUtils</h3><p>为 Collection 实例提供工具方法</p><p>CollectionUtils.addAll 可以将数组，集合加入到指定集合，解决需要将数组加入到集合中情况</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; listA &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">listA.add(&quot;1&quot;);</span><br><span class="line">listA.add(&quot;2&quot;);</span><br><span class="line">listA.add(&quot;3&quot;);</span><br><span class="line">String[] arrays &#x3D; new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;</span><br><span class="line">CollectionUtils.addAll(listA, arrays);</span><br></pre></td></tr></table></figure><p>CollectionUtils.isEmpty CollectionUtils.isNotEmpty 快捷判断集合是否为空</p><p><strong>集合和数组的处理</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ArrayUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ArrayUtils.isEmpty(Array);</span><br><span class="line"><span class="keyword">boolean</span> ArrayUtils.isNotEmpty(Array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> CollectionUtils.isEmpty(Collection);</span><br><span class="line"><span class="keyword">boolean</span> CollectionUtils.isNotEmpty(Collection);</span><br><span class="line">Collection CollectionUtils.union(a,b);<span class="comment">//并集</span></span><br><span class="line">Collection CollectionUtils.intersection(a,b);<span class="comment">//交集</span></span><br><span class="line">Collection CollectionUtils.disjunction(a,b);<span class="comment">//补集</span></span><br><span class="line">Collection CollectionUtils.subtract(a,b);<span class="comment">//差集</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断两个集合是否有相同的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两个集合如果有相同的元素返回true，反之返回false</span></span><br><span class="line"><span class="keyword">boolean</span> b = CollectionUtils.containsAny(list, list2);</span><br></pre></td></tr></table></figure><p>将数组转换成list集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平常在代码中将数组转换成list可能常用的java.util包 Arrays.asList()</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CollectionUtils工具类也提供了将诉数组转换成list，返回的list是没有泛型的</span></span><br><span class="line">List list = CollectionUtils.arrayToList(arr);</span><br></pre></td></tr></table></figure><p>获取集合list 或者 set 的最后一个元素</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;我们如果想要获取list的最后一个元素的话可以使用下标，因为list的有序的</span><br><span class="line">String last &#x3D; list.get(list.size() - 1);</span><br><span class="line">&#x2F;&#x2F;但是如果要获取set集合的最后一个元素就比较麻烦，set的无序的没有下标，但是可以使用CollectionUtils工具类</span><br><span class="line">String last &#x3D; CollectionUtils.lastElement(set);</span><br></pre></td></tr></table></figure><h2 id="commons-codec"><a href="#commons-codec" class="headerlink" title="commons-codec"></a>commons-codec</h2><h3 id="加解密相关"><a href="#加解密相关" class="headerlink" title="加解密相关"></a><strong>加解密相关</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] Base64.encodeBase64(<span class="keyword">byte</span> []);</span><br><span class="line"><span class="keyword">byte</span>[] Base64.decodeBase64(<span class="keyword">byte</span>[]);</span><br><span class="line"></span><br><span class="line">Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line">String text = <span class="string">&quot;字串文字&quot;</span>;</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">String encodedText = base64.encodeToString(text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(base64.decode(encodedText), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> [] Hex.encodeHex(<span class="keyword">byte</span> []);</span><br><span class="line"><span class="keyword">byte</span> [] Hex.decodeHex(<span class="keyword">char</span> []);</span><br><span class="line"></span><br><span class="line">String DigestUtils.md5Hex(String);</span><br><span class="line">String DigestUtils.shaHex(String);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与Spring Boot的摘要算法区别</p><h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>HttpClient是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。实现了所有 HTTP 的方法（GET,POST,PUT,HEAD 等）。以下是一个简单的Http请求使用GET方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建httpClient实例</span></span><br><span class="line">        HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="comment">//创建一个GET方法</span></span><br><span class="line">        GetMethod getMethod = <span class="keyword">new</span> GetMethod(<span class="string">&quot;http://ip:port/MySpringBootDemo/api/test&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//发起get请求</span></span><br><span class="line">            <span class="keyword">int</span> code = httpClient.executeMethod(getMethod);</span><br><span class="line">            <span class="keyword">if</span> (code != HttpStatus.SC_OK)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] responseBody = getMethod.getResponseBody();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(responseBody,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放连接</span></span><br><span class="line">            getMethod.releaseConnection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">............................................................................................................</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNpws</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\objective\\desc\\copy.txt&quot;</span>);</span><br><span class="line">        getFile(response,file);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFile</span><span class="params">(HttpServletResponse response,File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                OutputStream output = response.getOutputStream();</span><br><span class="line">                FileInputStream input = <span class="keyword">new</span> FileInputStream(file)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>((len=input.read(bts))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                output.write(bts,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HttpClient可以设置一些参数，使用HttpClientParams</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HttpClient设置参数</span></span><br><span class="line">httpClient.setParams(httpClientParams);</span><br><span class="line"></span><br><span class="line">HttpClientParams httpClientParams = <span class="keyword">new</span> HttpClientParams();</span><br><span class="line"><span class="comment">//设置连接超时时间，单位是毫秒</span></span><br><span class="line">httpClientParams.setConnectionManagerTimeout(<span class="keyword">long</span> timeout);</span><br><span class="line"><span class="comment">//设置是否先尝试身份验证</span></span><br><span class="line">setAuthenticationPreemptive(<span class="keyword">boolean</span> value)</span><br><span class="line"><span class="comment">//设置字符集</span></span><br><span class="line">setContentCharset(String charset)</span><br></pre></td></tr></table></figure><ul><li><strong>GetMethod</strong></li></ul><p>上面的示例中用到了GetMethod，从名称上能猜到这个类是发起GET请求的，那么它可能会提供一些get请求的配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置请求头,这个方法会覆盖原来的请求头</span><br><span class="line">setRequestHeader(Header header)</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;添加请求头，这个方法只是添加不会重写原来的请求头</span><br><span class="line">addRequestHeader(Header header)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;请求头的创建可以使用无参构造函数，然后通过Header的两个方法设置参数,请求头是键值对key，value形式的，如:</span><br><span class="line">Hearder header &#x3D; new Header();</span><br><span class="line">header.setName(&quot;appToken&quot;);</span><br><span class="line">header.setValue(&quot;adfdf&quot;);</span><br><span class="line">&#x2F;&#x2F;也可以通过有参构造函数直接创建</span><br><span class="line">Header header &#x3D; new Header(&quot;appToken&quot;,&quot;adfdf&quot;);</span><br></pre></td></tr></table></figure><p>请求类似IO流不能一直保持着，当请求完毕后要释放连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当响应处理完毕后要断开连接</span><br><span class="line">releaseConnection();</span><br><span class="line">PostMethod</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>http请求一般使用最多的就是get和post请求，下面我们看看PostMethod，其实和GetMethod类似</p><pre><code>public static void main(String[] args) &#123;    //创建HttpClient实例    HttpClient httpClient = new HttpClient();    String url = &quot;http://192.168.0.115:8899/MySpringBootDemo/api/npws&quot;;    PostMethod postMethod = new PostMethod(url);    //添加请求参数    postMethod.setParameter(&quot;ajbh&quot;,&quot;123&quot;);        Header header = new Header();    header.setName(&quot;token&quot;);    header.setValue(&quot;adfg&quot;);    //设置请求头    postMethod.setRequestHeader(header);    try &#123;        int code = httpClient.executeMethod(postMethod);        if (code != HttpStatus.SC_OK)&#123;            System.out.println(&quot;请求异常&quot;);        &#125;        byte[] responseBody = postMethod.getResponseBody();        System.out.println(new String(responseBody));    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;finally&#123;         postMethod.releaseConnection();    &#125;&#125;</code></pre><p>}<br>一般我们使用post请求消息类型会选择json格式的，PostMethod通过RequestEntity可以设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RequestEntity是一个接口，它有多个实现类分别是：</span></span><br><span class="line"><span class="comment">//StringRequestEntity; ByteArrayRequestEntity; FileRequestEntity; InputStreamRequestEntity; MultipartRequestEntity</span></span><br><span class="line"></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">RequestEntity requestEntity = <span class="keyword">new</span> StringRequestEntity(jsonObject.toString(),<span class="string">&quot;application/json&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">postMethod.setRequestEntity(requestEntity);</span><br></pre></td></tr></table></figure><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>Apache commons 包中有一个工具类HttpURLConnection，它是java.net.HttpURLConnection的子类，Apache commons中的HttpURLConnection的方法都是不可用的，其实我们一般使用的都使用java.net.HttpURLConnection，所以下面的示例也是java.net.HttpURLConnection</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要请求的ip和端口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String ruleManagerServerUrl = <span class="string">&quot;http://ip:端口&quot;</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前服务器地址</span></span><br><span class="line">            String localAddr = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            obj.put(<span class="string">&quot;ip&quot;</span>, localAddr);</span><br><span class="line">            obj.put(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(ruleManagerServerUrl + <span class="string">&quot;/api/addHost&quot;</span>);</span><br><span class="line">            HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">            connection.setConnectTimeout(<span class="number">3000</span>);</span><br><span class="line">            connection.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">            connection.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">            connection.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            String s = obj.toJSONString();</span><br><span class="line">            <span class="keyword">byte</span>[] writebytes = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            connection.setRequestProperty(<span class="string">&quot;Content-Length&quot;</span>, String.valueOf(writebytes.length));</span><br><span class="line">            OutputStream out = connection.getOutputStream();</span><br><span class="line">            out.write(writebytes);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">200</span> == connection.getResponseCode()) &#123;</span><br><span class="line">                String message = connection.getResponseMessage();</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;添加服务器名称失败&quot;</span>, message)) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;添加服务器名称失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;请求失败&quot;</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>平常开发中总会遇到加密的情况，比如登录的用户名和密码会通过加密后存储到数据库中，其实就是将实际的用户名和密码通过另外一种算法进行编码，隐藏了真正的内容，还有就是文本存储到数据库中的时候文本内容太大，那么就可以对文本内容进行编码比如Base64后存储到数据库中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">        Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line">        String base64Str ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Base64编码</span></span><br><span class="line">             base64Str = base64.encodeToString(str.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(base64Str);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;文本Base64编码异常&quot;</span>,e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> 结果：56iL5bqP5ZGY</span><br><span class="line">............................................................................................................</span><br><span class="line">        <span class="comment">//Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decode = base64.decode(base64Str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">     </span><br><span class="line">            String rs = <span class="keyword">new</span> String(decode,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;文本解码异常&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">结果：程序员</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>java.Util包中也有Base64</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">        String base64Str;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Base64编码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encode = Base64.getEncoder().encode(str.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            base64Str = <span class="keyword">new</span> String(encode,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(base64Str);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             logger.error(<span class="string">&quot;Base64编码异常&quot;</span>,e);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decode = Base64.getDecoder().decode(base64Str);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String rs = <span class="keyword">new</span> String(decode,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println(rs);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           logger.error(<span class="string">&quot;Base64解码异常&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DigestUtils"><a href="#DigestUtils" class="headerlink" title="DigestUtils"></a>DigestUtils</h3><p>DigestUtils是一个加密工具类，有各种加密的方法，但是我们常用到的是md5加密。当我们不知道这个工具类的时候想要对一段文字加密的时候会自己写md5加密算法，如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Util</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一种实现</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String string = <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] hexDigits=&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] btInput = string.getBytes();</span><br><span class="line">            <span class="comment">// 获得MD5摘要算法的 MessageDigest 对象</span></span><br><span class="line">            MessageDigest mdInst = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用指定的字节更新摘要</span></span><br><span class="line">            mdInst.update(btInput);</span><br><span class="line">            <span class="comment">// 获得密文</span></span><br><span class="line">            <span class="keyword">byte</span>[] md = mdInst.digest();</span><br><span class="line">            <span class="comment">// 把密文转换成十六进制的字符串形式</span></span><br><span class="line">            <span class="keyword">int</span> j = md.length;</span><br><span class="line">            <span class="keyword">char</span>[] str = <span class="keyword">new</span> <span class="keyword">char</span>[j * <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">byte</span> byte0 = md[i];</span><br><span class="line">                str[k++] = hexDigits[byte0 &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">                str[k++] = hexDigits[byte0 &amp; <span class="number">0xf</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">结果：72D9ADF4944F23E5EFDE37F6364C126F</span><br><span class="line">............................................................................................................</span><br><span class="line">    <span class="comment">//第二种实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String string = <span class="string">&quot;程序员&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            md5.update(string.getBytes());</span><br><span class="line">            <span class="keyword">byte</span>[] b = md5.digest();</span><br><span class="line"></span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; b.length; n++) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = b[n];</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    i += <span class="number">256</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(Integer.toHexString(i));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">结果：72d9adf4944f23e5efde37f6364c126f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上不论哪一种方法都需要大段的代码，如果项目中多处使用，还需要封装成一个工具类，其实Apache commons中已经有封装好的工具类，使用很方便，一行代码解决问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = DigestUtils.md5Hex(string);</span><br><span class="line">System.out.println(s);</span><br><span class="line">结果：72d9adf4944f23e5efde37f6364c126f</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然工具类DigestUtils还提供了其他的md5加密方法</span></span><br><span class="line"><span class="comment">//加密字节数组</span></span><br><span class="line">DigestUtils.md5Hex(<span class="keyword">byte</span>[]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加密流的</span></span><br><span class="line">DigestUtils.md5Hex(inputStream);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件压缩zip"><a href="#文件压缩zip" class="headerlink" title="文件压缩zip"></a>文件压缩zip</h2><p>zip普通方法压缩文件夹</p><p>方法1：压缩文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  BUFFER_SIZE = <span class="number">2</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//压缩文件名称</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\original.zip&quot;</span>);</span><br><span class="line">            <span class="comment">//创建文件输出流</span></span><br><span class="line">            FileOutputStream fileOutputStream = FileUtils.openOutputStream(file);</span><br><span class="line">            <span class="comment">//压缩文件</span></span><br><span class="line">            toZip(<span class="string">&quot;G:\\original&quot;</span>,fileOutputStream,<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;压缩文件异常&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩成ZIP </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcDir 压缩文件夹路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out    压缩文件输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepDirStructure  是否保留原来的目录结构(true:保留目录结构;false:所有文件跑到压缩包根目录下)</span></span><br><span class="line"><span class="comment">     *                          (注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RuntimeException 压缩失败会抛出运行时异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toZip</span><span class="params">(String srcDir, OutputStream out, <span class="keyword">boolean</span> keepDirStructure)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RuntimeException</span>&#123;</span><br><span class="line">        <span class="comment">//记录压缩开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建zip输出流</span></span><br><span class="line">        <span class="keyword">try</span> (ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(out))&#123;</span><br><span class="line">            File sourceFile = <span class="keyword">new</span> File(srcDir);</span><br><span class="line">            compress(sourceFile,zos,sourceFile.getName(),keepDirStructure);</span><br><span class="line">            <span class="comment">//记录压缩结束时间</span></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;压缩完成，耗时：&quot;</span> + (end - start) +<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;压缩文件&#123;&#125;异常&quot;</span>,srcDir,e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归压缩方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sourceFile 源文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zos        zip输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name       压缩后的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepDirStructure  是否保留原来的目录结构(true:保留目录结构;false:所有文件跑到压缩包根目录下)</span></span><br><span class="line"><span class="comment">     *                          (注意：不保留目录结构可能会出现同名文件,会压缩失败)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception  异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(File sourceFile, ZipOutputStream zos, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> keepDirStructure)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">if</span>(sourceFile.isFile())&#123;</span><br><span class="line">            <span class="comment">// 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字</span></span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name));</span><br><span class="line">            <span class="comment">// copy文件到zip输出流中</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                zos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            zos.closeEntry();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] listFiles = sourceFile.listFiles();</span><br><span class="line">            <span class="keyword">if</span>(listFiles == <span class="keyword">null</span> || listFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 需要保留原来的文件结构时,需要对空文件夹进行处理</span></span><br><span class="line">                <span class="keyword">if</span>(keepDirStructure)&#123;</span><br><span class="line">                    <span class="comment">// 空文件夹的处理</span></span><br><span class="line">                    zos.putNextEntry(<span class="keyword">new</span> ZipEntry(name + <span class="string">&quot;/&quot;</span>));</span><br><span class="line">                    <span class="comment">// 没有文件，不需要文件的copy</span></span><br><span class="line">                    zos.closeEntry();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : listFiles) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否需要保留原来的文件结构</span></span><br><span class="line">                    <span class="keyword">if</span> (keepDirStructure) &#123;</span><br><span class="line">                        <span class="comment">// 注意：file.getName()前面需要带上父文件夹的名字加一斜杠,</span></span><br><span class="line">                        <span class="comment">// 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了</span></span><br><span class="line">                        compress(file, zos, name + <span class="string">&quot;/&quot;</span> + file.getName(),keepDirStructure);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        compress(file, zos, file.getName(),keepDirStructure);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：压缩多个文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩成ZIP 压缩多个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFiles 需要压缩的文件列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out           压缩文件输出流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RuntimeException 压缩失败会抛出运行时异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toZip</span><span class="params">(List&lt;File&gt; srcFiles , OutputStream out)</span><span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(out))&#123;</span><br><span class="line">        <span class="keyword">for</span> (File srcFile : srcFiles) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            zos.putNextEntry(<span class="keyword">new</span> ZipEntry(srcFile.getName()));</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">            <span class="keyword">while</span> ((len = in.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                zos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            zos.closeEntry();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩完成，耗时：&quot;</span> + (end - start) +<span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;zip error from ZipUtils&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Apache commons也提供了压缩zip文件的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ZipArchiveEntry zipArchiveEntry = <span class="keyword">new</span> ZipArchiveEntry(<span class="string">&quot;压缩zip&quot;</span>);</span><br><span class="line">       File file = <span class="keyword">new</span> File(<span class="string">&quot;G:\\test1.txt&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> (FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line">           File zipFile = <span class="keyword">new</span> File(<span class="string">&quot;G:\\test1.zip&quot;</span>);</span><br><span class="line">           ZipArchiveOutputStream zipArchiveOutputStream = <span class="keyword">new</span> ZipArchiveOutputStream(zipFile);</span><br><span class="line">           zipArchiveOutputStream.putArchiveEntry(zipArchiveEntry);</span><br><span class="line">           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="keyword">int</span> len;</span><br><span class="line">           <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">               zipArchiveOutputStream.write(len);</span><br><span class="line">           &#125;</span><br><span class="line">           zipArchiveOutputStream.closeArchiveEntry();</span><br><span class="line">           zipArchiveOutputStream.close();</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然有压缩文件，那么必然需要解压</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解压Zip文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipFile</span></span><br><span class="line"><span class="comment"> *            需要解压的zip文件位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destDir</span></span><br><span class="line"><span class="comment"> *            解压的目标位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unzip</span><span class="params">(String zipFile, String destDir)</span> </span>&#123;</span><br><span class="line">    File f;</span><br><span class="line">    <span class="keyword">try</span> (ArchiveInputStream i = <span class="keyword">new</span> ArchiveStreamFactory().createArchiveInputStream(ArchiveStreamFactory.ZIP,</span><br><span class="line">            Files.newInputStream(Paths.get(zipFile)))) &#123;</span><br><span class="line">        ArchiveEntry entry ;</span><br><span class="line">        <span class="keyword">while</span> ((entry = i.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i.canReadEntryData(entry)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f = <span class="keyword">new</span> File(destDir, entry.getName());</span><br><span class="line">            <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f.isDirectory() &amp;&amp; !f.mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;failed to create directory &quot;</span> + f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                File parent = f.getParentFile();</span><br><span class="line">                <span class="keyword">if</span> (!parent.isDirectory() &amp;&amp; !parent.mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;failed to create directory &quot;</span> + parent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> (OutputStream o = Files.newOutputStream(f.toPath())) &#123;</span><br><span class="line">                    IOUtils.copy(i, o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ArchiveException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 秒表</span></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.StopWatch;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">stopWatch.getTime();</span><br><span class="line">stopWatch.stop();</span><br><span class="line"></span><br><span class="line"><span class="comment">//spring 获取方法参数名称</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.ParameterNameDiscoverer;</span><br><span class="line">ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">//spring 用于处理逗号分隔符的字符串列表方法</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line">String [] StringUtils.tokenizeToStringArray(String str, String delimiters);</span><br></pre></td></tr></table></figure><h2 id="Httpclient与RestTemplate的比较"><a href="#Httpclient与RestTemplate的比较" class="headerlink" title="Httpclient与RestTemplate的比较"></a>Httpclient与RestTemplate的比较</h2><p>（一）HttpClient 客户端</p><p>1、HttpClient 是 apache 的开源，需要引入两个包：httpclient-4.2.4.jar 和 httpcore-4.2.2.jar。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpClien 的客户端访问</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">httpClientVisit</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   </span><br><span class="line">    String clientResponse = <span class="string">&quot;&quot;</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">   </span><br><span class="line">        HttpClient client = <span class="keyword">new</span> DefaultHttpClient(); </span><br><span class="line">        HttpPost request = <span class="keyword">new</span> HttpPost(mUrl); </span><br><span class="line">   </span><br><span class="line">        <span class="comment">//不是表单数据提交，这边使用 StringEntity 即可 </span></span><br><span class="line">        <span class="comment">//UrlEncodedFormEntity等都是 HttpEntity 接口的实现类 </span></span><br><span class="line">        StringEntity entity = <span class="keyword">new</span> StringEntity(mRequestXml, <span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//编码 </span></span><br><span class="line">        entity.setContentType(<span class="string">&quot;text/xml&quot;</span>); </span><br><span class="line">        request.setEntity(entity); </span><br><span class="line">        <span class="comment">// 发送请求 </span></span><br><span class="line">        HttpResponse response = client.execute(request); </span><br><span class="line">   </span><br><span class="line">        org.apache.http.HttpEntity httpEntity = response.getEntity(); </span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (httpEntity != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// EntityUtils.toString 如果不指定编码，EntityUtils默认会使用ISO_8859_1进行编码 </span></span><br><span class="line">            clientResponse = EntityUtils.toString(httpEntity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 记得设置编码或者如下 </span></span><br><span class="line">            <span class="comment">// clientResponse = new String(EntityUtils.toString(httpEntity).getBytes(&quot;ISO_8859_1&quot;), &quot;UTF-8&quot;); </span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (clientResponse == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(clientResponse)) &#123; </span><br><span class="line">            System.err.println(<span class="string">&quot;clientResponse is null or empty.&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">           System.out.println(clientResponse);    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Apache全家桶不完全使用指南&quot;&gt;&lt;a href=&quot;#Apache全家桶不完全使用指南&quot; class=&quot;headerlink&quot; title=&quot;Apache全家桶不完全使用指南&quot;&gt;&lt;/a&gt;Apache全家桶不完全使用指南&lt;/h1&gt;&lt;p&gt;平常我们在日常的开发中会一些通用的功能封装成一些工具类，以便之后复用。但是有些常用功能，业界已经存在，我们无需造轮子，只需直接使用或借用它们的 Api ，构建我们的自己项目中工具类。这篇首先介绍平常用到的 Apache 工具全家桶。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;commons-lang3&lt;/li&gt;
&lt;li&gt;commons-io&lt;/li&gt;
&lt;li&gt;commons-collections&lt;/li&gt;
&lt;li&gt;commons-codec[加密-解密]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;</summary>
    
    
    
    
    <category term="Apache工具类" scheme="https://wllshdx.github.io/tags/Apache%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
</feed>
